// ********RoostGPT********
/*
Test generated by RoostGPT for test test-restassured using AI Type Azure Open AI and AI Model roostgpt-4-32k

Test generated for /country/{id}_put for http method type PUT in rest-assured framework

RoostTestHash=a43d945128


*/

// ********RoostGPT********
package com.bootexample4.RoostTest;

import io.restassured.RestAssured;
import io.restassured.path.json.JsonPath;
import io.restassured.http.ContentType;
import io.restassured.response.Response;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import java.util.List;
import java.util.Map;
import java.util.ArrayList;
import org.hamcrest.MatcherAssert;
import static org.hamcrest.Matchers.*;
import org.json.JSONObject;
import org.json.XML;
import org.json.JSONException;

public class CountryIdPutTest {

    private static final String DEFAULT_BASE_URL = "http://api.example.com/v1";
    private List<Map<String, String>> envList = new ArrayList<>();

    @BeforeEach
    public void setUp() {
        TestdataLoader dataloader = new TestdataLoader();
        String[] envVarsList = {"id"};
        envList = dataloader.load("src/test/java/com/bootexample4/RoostTest/country_idPutTest.csv", envVarsList);
    }

    @Test
    public void countryIdPut_Test() throws JSONException {
        setUp();
        int testNumber = 1;

        for (Map<String, String> testData : envList) {
            // Base URL setup
            RestAssured.baseURI = testData.getOrDefault("url1_country2_BASE_URL", DEFAULT_BASE_URL);

            // Constructing the request body
            JSONObject requestBodyObject = testData.containsKey("RequestBody") 
                                           ? new JSONObject(testData.get("RequestBody")) 
                                           : new JSONObject();

            // Sending the PUT request
            Response responseObj = given()
                    .header("app-identifier", testData.getOrDefault("app-identifier", ""))
                    .header("customer-secret-key", testData.getOrDefault("customer-secret-key", ""))
                    .pathParam("id", testData.getOrDefault("id", ""))
                    .contentType(ContentType.JSON)
                    .body(requestBodyObject.toString())
                    .header("Authorization", "Bearer " + testData.get("url1_country2_bearer"))
                    .when()
                    .put("/country/{id}")
                    .then()
                    .extract()
                    .response();

            // Logging test case information
            System.out.printf("Test Case %d: countryIdPut_Test \n", testNumber++);
            System.out.println("Request: PUT /country/{id}");
            System.out.println("Status Code: " + responseObj.statusCode());

            validateStatusCode(responseObj, testData);
            handleContentType(responseObj);
        }
    }

    private void validateStatusCode(Response responseObj, Map<String, String> testData) {
        if (testData.containsKey("statusCode")) {
            String expectedStatusCode = testData.get("statusCode");

            if (expectedStatusCode.contains("X")) {
                // Validate status code category
                MatcherAssert.assertThat("Status code category mismatch", 
                        Integer.toString(responseObj.statusCode()).charAt(0), 
                        equalTo(expectedStatusCode.charAt(0)));
            } else {
                // Validate the exact status code
                MatcherAssert.assertThat("Exact status code mismatch", 
                        Integer.toString(responseObj.statusCode()), equalTo(expectedStatusCode));
            }
        } else {
            // Default expected status code validation (200 OK)
            MatcherAssert.assertThat("Unexpected status code", responseObj.statusCode(), is(200));
        }

        switch (responseObj.statusCode()) {
            case 200:
                validateSuccessResponse(responseObj);
                break;
            case 400:
                validateErrorResponse(responseObj);
                break;
            case 404:
                validateNotFoundResponse(responseObj);
                break;
            case 422:
                validateUnprocessableEntityResponse(responseObj);
                break;
            default:
                System.out.println("Unhandled status code: " + responseObj.statusCode());
        }
    }

    private void handleContentType(Response responseObj) {
        String contentType = responseObj.getContentType();

        JsonPath response;
        if (contentType.contains("application/xml") || contentType.contains("text/xml")) {
            String xmlResponse = responseObj.asString();
            JSONObject jsonResponse = XML.toJSONObject(xmlResponse);
            JSONObject jsonData = jsonResponse.getJSONObject("xml");
            response = new JsonPath(jsonData.toString());
        } else if (contentType.contains("application/json")) {
            response = responseObj.jsonPath();
        } else {
            System.err.println("Unsupported content type: " + contentType);
        }
    }

    private void validateSuccessResponse(Response responseObj) {
        JsonPath response = responseObj.jsonPath();
        System.out.println("Description: Country updated successfully");

        MatcherAssert.assertThat("Incorrect type for 'status'", response.get("status"), instanceOf(String.class));
        MatcherAssert.assertThat("Incorrect type for 'message'", response.get("message"), instanceOf(String.class));
        MatcherAssert.assertThat("Incorrect type for 'error_info'", response.get("error_info"), instanceOf(String.class));
    }

    private void validateErrorResponse(Response responseObj) {
        JsonPath response = responseObj.jsonPath();
        System.out.println("Validation failed for the request payload");

        MatcherAssert.assertThat("Status should be present and a string", response.get("status"), instanceOf(String.class));
        MatcherAssert.assertThat("Error message should be descriptive", response.get("error_description"), is(not(emptyOrNullString())));
        MatcherAssert.assertThat("Error details should be available", response.get("error_details"), is(not(empty())));
    }

    private void validateNotFoundResponse(Response responseObj) {
        JsonPath response = responseObj.jsonPath();
        System.out.println("Requested resource not found");

        MatcherAssert.assertThat("Status should indicate failure", response.get("status"), is(equalTo("NOT_FOUND")));
        MatcherAssert.assertThat("Error message should be descriptive", response.get("error_message"), is(not(emptyOrNullString())));
    }

    private void validateUnprocessableEntityResponse(Response responseObj) {
        JsonPath response = responseObj.jsonPath();
        System.out.println("Unprocessable entity due to invalid input");

        MatcherAssert.assertThat("Status should indicate unprocessable entity", response.get("status"), is(equalTo("UNPROCESSABLE_ENTITY")));
        MatcherAssert.assertThat("Error summary should be informative", response.get("error_summary"), is(not(emptyOrNullString())));
        MatcherAssert.assertThat("Detailed validation errors should be present", response.get("validation_errors"), is(not(empty())));
    }
}
