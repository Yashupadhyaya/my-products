// ********RoostGPT********
/*
Test generated by RoostGPT for test testingartillerytest using AI Type Azure Open AI and AI Model roostgpt-4-32k

Test generated for /nobelPrize/{category}/{year}_get for http method type GET in rest-assured framework

RoostTestHash=968c47d2dc

[
  {
    "ScenarioID": "1",
    "TestName": "testValidRequestReturns200",
    "Description": "Test a valid request with appropriate category and year parameters",
    "Execution": {
      "Arrange": "Prepare valid path parameters 'category=lit' and 'year=2021'",
      "Act": "Send GET request to /2.1/nobelPrize/lit/2021",
      "Assert": "Check for 200 status code and ensure response contains valid Nobel Prize details"
    },
    "Validation": "Ensures API successfully returns correct response for valid inputs"
  },
  {
    "ScenarioID": "2",
    "TestName": "testInvalidCategoryReturns400",
    "Description": "Test an invalid request with unsupported category value",
    "Execution": {
      "Arrange": "Prepare path parameters with invalid 'category=invalid' and valid 'year=2021'",
      "Act": "Send GET request to /2.1/nobelPrize/invalid/2021",
      "Assert": "Check for 400 status code and error message indicating category is invalid"
    },
    "Validation": "Validates API response for unsupported enum values in category parameter"
  },
  {
    "ScenarioID": "3",
    "TestName": "testMissingCategoryPathParamReturns404",
    "Description": "Test a request missing the mandatory category path parameter",
    "Execution": {
      "Arrange": "Prepare request with only 'year=2021' in the path, omitting category",
      "Act": "Send GET request to /2.1/nobelPrize//2021",
      "Assert": "Check for 404 status code and error message indicating resource not found"
    },
    "Validation": "Ensures API responds correctly when mandatory category parameter is missing"
  },
  {
    "ScenarioID": "4",
    "TestName": "testInvalidYearBelowMinimumReturns422",
    "Description": "Test a request with year below the minimum value of 1901",
    "Execution": {
      "Arrange": "Prepare path parameters 'category=phy' and 'year=1800'",
      "Act": "Send GET request to /2.1/nobelPrize/phy/1800",
      "Assert": "Check for 422 status code and error message indicating year is invalid"
    },
    "Validation": "Verifies API correctly handles invalid year parameter below allowed range"
  },
  {
    "ScenarioID": "5",
    "TestName": "testYearAsStringReturns400",
    "Description": "Test a request with year parameter as a string instead of an integer",
    "Execution": {
      "Arrange": "Prepare path parameters 'category=med' and 'year=wrongYear'",
      "Act": "Send GET request to /2.1/nobelPrize/med/wrongYear",
      "Assert": "Check for 400 status code and error message indicating year type mismatch"
    },
    "Validation": "Ensures API responds with error for incorrect parameter types"
  },
  {
    "ScenarioID": "6",
    "TestName": "testValidCategoryAndYearReturnsCorrectResponseStructure",
    "Description": "Test if the response structure matches the expected schema when valid inputs are provided",
    "Execution": {
      "Arrange": "Prepare valid path parameters 'category=che' and 'year=2015'",
      "Act": "Send GET request to /2.1/nobelPrize/che/2015",
      "Assert": "Check for 200 status code and ensure response schema matches defined structure with all fields"
    },
    "Validation": "Ensures API returns the correct response structure for valid inputs"
  },
  {
    "ScenarioID": "7",
    "TestName": "testMissingYearPathParamReturns404",
    "Description": "Test a request missing the mandatory year path parameter",
    "Execution": {
      "Arrange": "Prepare request with only 'category=lit' in the path, omitting year",
      "Act": "Send GET request to /2.1/nobelPrize/lit/",
      "Assert": "Check for 404 status code and error message indicating resource not found"
    },
    "Validation": "Ensures API correctly handles requests with missing year parameter"
  },
  {
    "ScenarioID": "8",
    "TestName": "testFutureYearReturns422",
    "Description": "Test a request with year parameter set to a value beyond the current year",
    "Execution": {
      "Arrange": "Prepare path parameters 'category=eco' and 'year=3000'",
      "Act": "Send GET request to /2.1/nobelPrize/eco/3000",
      "Assert": "Check for 422 status code and error message indicating invalid year value"
    },
    "Validation": "Ensures API correctly identifies and rejects future year values"
  },
  {
    "ScenarioID": "9",
    "TestName": "testMultipleRequestsInvalidAndValidScenarios",
    "Description": "Perform sequential requests to test both valid and invalid scenarios",
    "Execution": {
      "Arrange": "Prepare valid category 'pea' and year '1999'; Prepare invalid category 'abc' and valid year '2005'",
      "Act": "Send GET request to /2.1/nobelPrize/pea/1999 followed by /2.1/nobelPrize/abc/2005",
      "Assert": "Ensure first request returns 200 with valid data and second request returns 400 with error message"
    },
    "Validation": "Verifies API behavior in handling multiple consecutive requests"
  },
  {
    "ScenarioID": "10",
    "TestName": "testMalformedURLReturns400",
    "Description": "Test a request with a malformed URL by inserting special characters",
    "Execution": {
      "Arrange": "Prepare a URL with invalid path parameters 'category=@med' and 'year=2020'",
      "Act": "Send GET request to /2.1/nobelPrize/@med/2020",
      "Assert": "Check for 400 status code and error message indicating malformed syntax"
    },
    "Validation": "Ensures API gracefully handles malformed URL inputs"
  }
]

*/

// ********RoostGPT********
package com.bootexample4.RoostTest;

import io.restassured.RestAssured;
import io.restassured.response.Response;
import io.restassured.specification.RequestSpecification;
import org.hamcrest.MatcherAssert;
import org.json.JSONObject;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.*;
import static io.restassured.RestAssured.given;
import static org.hamcrest.Matchers.equalTo;

public class NobelPrizeCategoryYearGetTest {

    private static final String BASE_URI = "http://api.nobelprize.org/2.1";
    private static final String AUTH_TOKEN_PLACEHOLDER = "${AUTH_TOKEN}";
    private List<JSONObject> testCases = new ArrayList<>();

    @BeforeEach
    public void setUp() {
        // Load test data from the JSON file.
        TestdataLoader dataLoader = new TestdataLoader();
        this.testCases = dataLoader.loadJson("src/test/java/com/bootexample4/RoostTest/nobelPrize_category_yearGetTest.JSON");
        RestAssured.baseURI = BASE_URI;
    }

    @Test
    public void testNobelPrizeCategoryYearAPI() {
        int testCaseNumber = 1;

        for (JSONObject testCase : testCases) {
            String requestPath = getRequestPath(testCase.optJSONObject("path_params"));
            RequestSpecification requestSpecification = createRequestSpecification(testCase);

            // Perform API request based on HTTP method (default is GET).
            Response response = executeRequest(requestSpecification, requestPath, testCase.optString("method", "get"));

            System.out.println("Executing Test Case " + testCaseNumber + ": " + testCase.optString("description"));
            System.out.println("Request Path: " + requestPath);
            System.out.println("Status Code: " + response.statusCode());

            validateResponse(response, testCase.optJSONObject("expected_response"));
            testCaseNumber++;
        }
    }

    /**
     * Creates the request path by replacing placeholders with path parameters.
     */
    private String getRequestPath(JSONObject pathParams) {
        String requestPath = "/nobelPrize/{category}/{year}";

        if (pathParams != null) {
            for (String key : pathParams.keySet()) {
                requestPath = requestPath.replace("{" + key + "}", pathParams.getString(key));
            }
        }
        return requestPath;
    }

    /**
     * Configures the request specification with headers, query parameters, and body.
     */
    private RequestSpecification createRequestSpecification(JSONObject testCase) {
        RequestSpecification requestSpecification = given();

        // Set headers.
        JSONObject headers = testCase.optJSONObject("request_header");
        if (headers != null) {
            for (String key : headers.keySet()) {
                String value = headers.getString(key);

                if ("Authorization".equalsIgnoreCase(key) && AUTH_TOKEN_PLACEHOLDER.equals(value)) {
                    String resolvedAuthToken = resolveAuthToken();
                    requestSpecification.header("Authorization", "Bearer " + resolvedAuthToken);
                } else {
                    requestSpecification.header(key, value);
                }
            }
        } else {
            // Add Authorization header if not provided explicitly.
            String resolvedAuthToken = resolveAuthToken();
            requestSpecification.header("Authorization", "Bearer " + resolvedAuthToken);
        }

        // Add query parameters.
        JSONObject queryParams = testCase.optJSONObject("query_params");
        if (queryParams != null) {
            for (String key : queryParams.keySet()) {
                requestSpecification.queryParam(key, queryParams.get(key));
            }
        }

        // Add request body.
        JSONObject requestBody = testCase.optJSONObject("request_body");
        if (requestBody != null && requestBody.length() > 0) {
            requestSpecification.body(requestBody.toString());
        }

        return requestSpecification;
    }

    /**
     * Resolves the authorization token using environment variables or other fallback mechanisms.
     */
    private String resolveAuthToken() {
        String envAuthToken = System.getenv("AUTH_TOKEN");
        return (envAuthToken != null && !envAuthToken.isEmpty()) ? envAuthToken : "default-token-placeholder";
    }

    /**
     * Executes the API request based on the HTTP method.
     */
    private Response executeRequest(RequestSpecification requestSpecification, String requestPath, String method) {
        switch (method.toLowerCase()) {
            case "post":
                return requestSpecification.when().post(requestPath).thenReturn();
            case "put":
                return requestSpecification.when().put(requestPath).thenReturn();
            case "delete":
                return requestSpecification.when().delete(requestPath).thenReturn();
            default: // Default to GET
                return requestSpecification.when().get(requestPath).thenReturn();
        }
    }

    /**
     * Validates the response against the expected values.
     */
    private void validateResponse(Response response, JSONObject expectedResponse) {
        int expectedStatusCode = expectedResponse.optInt("status_code", 200);
        MatcherAssert.assertThat("Expected status code " + expectedStatusCode + " but got " + response.statusCode(),
                response.statusCode(), equalTo(expectedStatusCode));

        // Check for specific error responses based on the status code
        switch (expectedStatusCode) {
            case 400:
                validateErrorResponse(response);
                break;
            case 404:
                validateNotFoundResponse(response);
                break;
            case 422:
                validateUnprocessableEntityResponse(response);
                break;
            case 200:
                validateSuccessResponse(response, expectedResponse);
                break;
            default:
                throw new IllegalStateException("Unexpected status code: " + expectedStatusCode);
        }
    }

    /**
     * Validates success response structure and values when status code is 200.
     */
    private void validateSuccessResponse(Response response, JSONObject expectedResponse) {
        if (expectedResponse.has("schema")) {
            response.then().body(matchesJsonSchemaInClasspath(expectedResponse.getString("schema")));
        } else {
            // Validate any specific fields from the response body if needed.
            response.then().body("category", notNullValue())
                   .body("year", notNullValue());
        }
    }

    /**
     * Validates error response structure for 400 Bad Request.
     */
    private void validateErrorResponse(Response response) {
        response.then().body("error", notNullValue())
               .body("message", containsString("Invalid"));
    }

    /**
     * Validates 404 Not Found response structure.
     */
    private void validateNotFoundResponse(Response response) {
        response.then().body("error", notNullValue())
               .body("message", containsString("Resource not found"));
    }

    /**
     * Validates 422 Unprocessable Entity response structure.
     */
    private void validateUnprocessableEntityResponse(Response response) {
        response.then().body("error", notNullValue())
               .body("message", containsString("Invalid year"));
    }

}
