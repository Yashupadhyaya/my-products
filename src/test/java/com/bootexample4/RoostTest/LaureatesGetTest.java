// ********RoostGPT********
/*
Test generated by RoostGPT for test testingartillerytest using AI Type Azure Open AI and AI Model roostgpt-4-32k

Test generated for /laureates_get for http method type GET in rest-assured framework

RoostTestHash=1e43731d2a

[
  {
    "ScenarioID": "1",
    "TestName": "testValidLaureateQuery",
    "Description": "Valid request to GET laureates with offset and limit parameters",
    "Execution": {
      "Arrange": "Prepare valid offset=1 and limit=10 query parameters",
      "Act": "Send GET request to /2.1/laureates with query params and headers",
      "Assert": "Verify response status is 200 and laureates array is returned with 10 items"
    },
    "Validation": "API successfully handles pagination and returns results as expected"
  },
  {
    "ScenarioID": "2",
    "TestName": "testMissingOffsetAndLimitParams",
    "Description": "Request laureates without optional offset and limit parameters",
    "Execution": {
      "Arrange": "Do not include offset or limit query params",
      "Act": "Send GET request to /2.1/laureates",
      "Assert": "Verify response status is 200 and default pagination is applied"
    },
    "Validation": "API handles missing optional query parameters gracefully"
  },
  {
    "ScenarioID": "3",
    "TestName": "testInvalidOffsetValue",
    "Description": "Pass invalid (negative) offset value in query",
    "Execution": {
      "Arrange": "Prepare query params with offset=-5",
      "Act": "Send GET request to /2.1/laureates with invalid offset parameter",
      "Assert": "Verify response status is 400 and error message indicates invalid offset value"
    },
    "Validation": "API rejects invalid numeric values that violate constraints"
  },
  {
    "ScenarioID": "4",
    "TestName": "testInvalidLimitValue",
    "Description": "Pass invalid (non-integer) limit value in query",
    "Execution": {
      "Arrange": "Prepare query params with limit='abc'",
      "Act": "Send GET request to /2.1/laureates with invalid limit parameter",
      "Assert": "Verify response status is 400 and error message indicates invalid limit value"
    },
    "Validation": "API rejects non-integer values for integer fields in query parameters"
  },
  {
    "ScenarioID": "5",
    "TestName": "testMissingBirthDateWithBirthDateTo",
    "Description": "Pass birthDateTo without mandatory birthDate parameter",
    "Execution": {
      "Arrange": "Prepare query params with birthDateTo=2000-01-01 but omit birthDate",
      "Act": "Send GET request to /2.1/laureates with incomplete date range parameters",
      "Assert": "Verify response status is 400 and error message indicates missing birthDate"
    },
    "Validation": "API enforces dependent parameter rules correctly"
  },
  {
    "ScenarioID": "6",
    "TestName": "testInvalidSortValue",
    "Description": "Pass an invalid sort value outside of allowed enum values",
    "Execution": {
      "Arrange": "Prepare query params with sort='random'",
      "Act": "Send GET request to /2.1/laureates with invalid sort parameter",
      "Assert": "Verify response status is 400 and error message indicates invalid sort value"
    },
    "Validation": "API validates enum constraints for query parameters"
  },
  {
    "ScenarioID": "7",
    "TestName": "testValidGenderEnum",
    "Description": "Query laureates with a valid gender parameter",
    "Execution": {
      "Arrange": "Prepare query params with gender='male'",
      "Act": "Send GET request to /2.1/laureates",
      "Assert": "Verify response status is 200 and returned laureates are filtered by gender"
    },
    "Validation": "API correctly filters results based on gender parameter"
  },
  {
    "ScenarioID": "8",
    "TestName": "testInvalidGenderEnum",
    "Description": "Pass an invalid gender value outside of allowed enum values",
    "Execution": {
      "Arrange": "Prepare query params with gender='unknown'",
      "Act": "Send GET request to /2.1/laureates with invalid gender parameter",
      "Assert": "Verify response status is 400 and error message indicates invalid gender value"
    },
    "Validation": "API validates enum constraints for gender query parameter"
  },
  {
    "ScenarioID": "9",
    "TestName": "testEmptyQueryParams",
    "Description": "Send request with no query parameters",
    "Execution": {
      "Arrange": "Prepare empty query parameters",
      "Act": "Send GET request to /2.1/laureates",
      "Assert": "Verify response status is 200 and all laureates are returned"
    },
    "Validation": "API handles empty queries and returns default results"
  },
  {
    "ScenarioID": "10",
    "TestName": "testMalformedQueryParams",
    "Description": "Send request with malformed query parameters",
    "Execution": {
      "Arrange": "Prepare query params with birthDate='xyz'",
      "Act": "Send GET request to /2.1/laureates with malformed birthDate parameter",
      "Assert": "Verify response status is 400 and error message indicates malformed query parameter"
    },
    "Validation": "API responds with appropriate error for malformed syntax"
  },
  {
    "ScenarioID": "11",
    "TestName": "testValidNobelPrizeCategory",
    "Description": "Filter laureates by valid Nobel Prize category enum value",
    "Execution": {
      "Arrange": "Prepare query params with nobelPrizeCategory='phy'",
      "Act": "Send GET request to /2.1/laureates",
      "Assert": "Verify response status is 200 and laureates are filtered by category"
    },
    "Validation": "API correctly filters valid enum values for Nobel Prize category"
  },
  {
    "ScenarioID": "12",
    "TestName": "testInvalidNobelPrizeCategory",
    "Description": "Pass a Nobel Prize category value outside allowed enum",
    "Execution": {
      "Arrange": "Prepare query params with nobelPrizeCategory='unknown'",
      "Act": "Send GET request to /2.1/laureates with invalid category parameter",
      "Assert": "Verify response status is 400 and error message indicates invalid category value"
    },
    "Validation": "API rejects invalid Nobel Prize category values"
  },
  {
    "ScenarioID": "13",
    "TestName": "testFormatAsCSV",
    "Description": "Request laureates data with format set as csv and language as se",
    "Execution": {
      "Arrange": "Prepare query params with format='csv' and csvLang='se'",
      "Act": "Send GET request to /2.1/laureates",
      "Assert": "Verify response status is 200 and response is in CSV format with language Swedish"
    },
    "Validation": "API correctly renders responses in CSV format based on language parameter"
  },
  {
    "ScenarioID": "14",
    "TestName": "testMissingRequiredParametersForRange",
    "Description": "Pass yearTo without mandatory nobelPrizeYear parameter",
    "Execution": {
      "Arrange": "Prepare query params with yearTo=2020 but omit nobelPrizeYear",
      "Act": "Send GET request to /2.1/laureates with incomplete range parameters",
      "Assert": "Verify response status is 400 and error message indicates missing nobelPrizeYear"
    },
    "Validation": "API enforces dependent parameter rules for year ranges"
  },
  {
    "ScenarioID": "15",
    "TestName": "testNoMatchingResults",
    "Description": "Query laureates with criteria that yield no results",
    "Execution": {
      "Arrange": "Prepare query params with birthCity='NonExistentCity'",
      "Act": "Send GET request to /2.1/laureates",
      "Assert": "Verify response status is 200 and laureates array in response is empty"
    },
    "Validation": "API handles queries with zero matching results gracefully"
  }
]

*/

// ********RoostGPT********
package com.bootexample4.RoostTest;

import org.json.JSONObject;
import io.restassured.RestAssured;
import io.restassured.response.Response;
import io.restassured.specification.RequestSpecification;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import java.util.*;
import static io.restassured.RestAssured.given;
import static org.hamcrest.Matchers.*;
import org.hamcrest.MatcherAssert;

public class LaureatesGetTest {

    private List<JSONObject> testCases = new ArrayList<>();
    private static final String BASE_URI = "http://api.nobelprize.org/2.1";
    private static final String AUTH_TOKEN_PLACEHOLDER = "${AUTH_TOKEN}";

    @BeforeEach
    public void setUp() {
        TestdataLoader dataloader = new TestdataLoader();
        testCases = dataloader.loadJson("src/test/java/com/bootexample4/RoostTest/laureatesGetTest.JSON");
        RestAssured.baseURI = BASE_URI;
    }

    @Test
    public void LaureatesGet_Test() {
        int testNumber = 1;

        for (JSONObject testData : testCases) {
            String requestPath = resolvePathParameters(testData.optJSONObject("path_params"), "/laureates");
            RequestSpecification requestSpec = buildRequestSpecification(testData);

            Response response = sendRequest(requestSpec, requestPath, "get");

            logTestDetails(testNumber++, requestPath, response);

            validateResponse(testData, response);
        }
    }

    private String resolvePathParameters(JSONObject pathParams, String requestPath) {
        if (pathParams != null) {
            for (String key : pathParams.keySet()) {
                requestPath = requestPath.replace("{" + key + "}", pathParams.getString(key));
            }
        }
        return requestPath;
    }

    private RequestSpecification buildRequestSpecification(JSONObject testData) {
        RequestSpecification req = given();

        // Set headers
        JSONObject requestHeader = testData.optJSONObject("request_header");
        String resolvedAuthToken = resolveAuthToken();
        boolean authSet = false;

        if (requestHeader != null) {
            for (String key : requestHeader.keySet()) {
                String value = requestHeader.getString(key);
                if (key.equalsIgnoreCase("Authorization")) {
                    String token = value.equalsIgnoreCase(AUTH_TOKEN_PLACEHOLDER) ? "Bearer " + resolvedAuthToken : value;
                    req.header(key, token);
                    authSet = true;
                } else {
                    req.header(key, value);
                }
            }
        }

        if (!authSet && resolvedAuthToken != null && !resolvedAuthToken.isEmpty()) {
            req.header("Authorization", "Bearer " + resolvedAuthToken);
        }

        // Set query parameters
        JSONObject queryParams = testData.optJSONObject("query_params");
        if (queryParams != null) {
            for (String key : queryParams.keySet()) {
                req.queryParam(key, queryParams.get(key));
            }
        }

        // Set request body
        JSONObject requestBody = testData.optJSONObject("request_body");
        if (requestBody != null && requestBody.length() > 0) {
            req.body(requestBody.toString());
        }

        return req;
    }

    private Response sendRequest(RequestSpecification req, String requestPath, String httpMethod) {
        switch (httpMethod.toLowerCase()) {
            case "post":
                return req.post(requestPath).then().extract().response();
            case "get":
                return req.get(requestPath).then().extract().response();
            case "put":
                return req.put(requestPath).then().extract().response();
            case "delete":
                return req.delete(requestPath).then().extract().response();
            default:
                throw new RuntimeException("Unsupported HTTP method: " + httpMethod);
        }
    }

    private void logTestDetails(int testNumber, String requestPath, Response response) {
        System.out.printf("Test Case %d: LaureatesGet_Test\n", testNumber);
        System.out.println("Request: GET " + requestPath);
        System.out.println("Status Code: " + response.statusCode());
    }

    private void validateResponse(JSONObject testData, Response response) {
        if (testData.has("expected_status_code")) {
            int expectedCode = testData.getInt("expected_status_code");
            MatcherAssert.assertThat("Expected status code " + expectedCode + " but got " + response.statusCode(),
                    response.statusCode(), equalTo(expectedCode));
        }

        if (response.statusCode() == 400) {
            validateErrorResponse(response);
        } else if (response.statusCode() == 404) {
            validateNotFoundResponse(response);
        } else if (response.statusCode() == 422) {
            validateUnprocessableEntityResponse(response);
        }
    }

    private void validateErrorResponse(Response response) {
        JSONObject responseJson = new JSONObject(response.asString());
        MatcherAssert.assertThat(responseJson.optString("error"), notNullValue());
        MatcherAssert.assertThat(responseJson.optString("message"), containsString("invalid"));
    }

    private void validateNotFoundResponse(Response response) {
        JSONObject responseJson = new JSONObject(response.asString());
        MatcherAssert.assertThat(responseJson.optString("error"), equalTo("Not Found"));
    }

    private void validateUnprocessableEntityResponse(Response response) {
        JSONObject responseJson = new JSONObject(response.asString());
        MatcherAssert.assertThat(responseJson.optString("error"), notNullValue());
        MatcherAssert.assertThat(responseJson.optString("message"), containsString("unprocessable"));
    }

    private String resolveAuthToken() {
        String envAuthToken = System.getenv("AUTH_TOKEN");
        return (envAuthToken != null && !envAuthToken.isEmpty()) ? envAuthToken : "default_token";
    }
}
