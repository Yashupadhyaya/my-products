{
  "item": [
    {
      "name": "api/v2",
      "item": [
        {
          "name": "/api/v2/readings",
          "request": {
            "name": "/api/v2/readings",
            "description": {},
            "url": {
              "path": [
                "api",
                "v2",
                "readings"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "disabled": false,
                  "key": "start",
                  "value": "{{start}}",
                  "description": "\"The start datetime for the window of readings\" \\\n\"Readings before this datetime will not be included in the results\" \\\n\"If this parameter is not specified, the most recent reading for each Asset will be provided\"\n"
                },
                {
                  "disabled": false,
                  "key": "end",
                  "value": "{{end}}",
                  "description": "\"The end datetime for the window of readings\" \\\n\"Readings after this datetime will not be included in the results\" \\\n\"A valid 'start' parameter must be included if this parameter is used\"\n"
                },
                {
                  "disabled": false,
                  "key": "sort",
                  "value": "{{sort}}",
                  "description": "\"The parameter with which to sort the highest level of items returned by the endpoint\"\n"
                },
                {
                  "disabled": false,
                  "key": "page",
                  "value": "{{page}}",
                  "description": "\"The page number of results to be loaded, e.g. page 3 of 5\" \\\n\"A valid 'per' parameter must be included if this parameter is used\"\n"
                },
                {
                  "disabled": false,
                  "key": "per",
                  "value": "{{per}}",
                  "description": "\"The number of results to load per page, e.g. 25 per page\" \\\n\"A valid 'page' parameter must be included if this parameter is used\"\n"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "auth": null
          },
          "response": [
            {
              "name": "Readings for all Assets in the system with an Active or Disabled status",
              "originalRequest": {
                "url": {
                  "path": [
                    "api",
                    "v2",
                    "readings"
                  ],
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "query": [
                    {
                      "key": "start",
                      "value": "{{start}}"
                    },
                    {
                      "key": "end",
                      "value": "{{end}}"
                    },
                    {
                      "key": "sort",
                      "value": "{{sort}}"
                    },
                    {
                      "key": "page",
                      "value": "{{page}}"
                    },
                    {
                      "key": "per",
                      "value": "{{per}}"
                    },
                    {
                      "key": "token",
                      "value": "{{token}}"
                    }
                  ],
                  "variable": []
                },
                "header": [
                  {
                    "key": "Accept",
                    "value": "application/json"
                  }
                ],
                "method": "GET",
                "body": {}
              },
              "status": "OK",
              "code": 200,
              "header": [
                {
                  "key": "Content-Type",
                  "value": "application/json"
                }
              ],
              "body": "{\n  \"data\": {\n    \"assets\": [\n      {\n        \"1\": {\n          \"sample_type\": \"aliqua do commodo\",\n          \"units\": \"fugiat laboru\",\n          \"readings\": [\n            {\n              \"value\": 84470145.1836093,\n              \"time\": \"labore laboris consequat id\"\n            },\n            {\n              \"value\": 55811691.18764418,\n              \"time\": \"ea Excepteur dolore voluptate aliqua\"\n            }\n          ]\n        },\n        \"id\": 78036518.34182456,\n        \"name\": \"reprehenderit non ea\",\n        \"tag\": \"Ut occa\",\n        \"state\": \"Excepteur laboris nisi\"\n      },\n      {\n        \"1\": {\n          \"sample_type\": \"dolor aute ut ad\",\n          \"units\": \"do reprehenderit sunt exe\",\n          \"readings\": [\n            {\n              \"value\": 26919675.267312065,\n              \"time\": \"deseru\"\n            },\n            {\n              \"value\": -46977539.09432421,\n              \"time\": \"enim mollit laborum\"\n            }\n          ]\n        },\n        \"id\": 38379290.74150601,\n        \"name\": \"incididunt consectetur\",\n        \"tag\": \"anim Lorem commodo\",\n        \"state\": \"deserunt ex\"\n      }\n    ]\n  },\n  \"errors\": [\n    \"ut sint deserunt\",\n    \"anim sed cupidatat\"\n  ]\n}",
              "cookie": [],
              "_postman_previewlanguage": "json"
            },
            {
              "name": "Invalid start or end parameter provided, or end provided without start",
              "originalRequest": {
                "url": {
                  "path": [
                    "api",
                    "v2",
                    "readings"
                  ],
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "query": [
                    {
                      "key": "start",
                      "value": "{{start}}"
                    },
                    {
                      "key": "end",
                      "value": "{{end}}"
                    },
                    {
                      "key": "sort",
                      "value": "{{sort}}"
                    },
                    {
                      "key": "page",
                      "value": "{{page}}"
                    },
                    {
                      "key": "per",
                      "value": "{{per}}"
                    },
                    {
                      "key": "token",
                      "value": "{{token}}"
                    }
                  ],
                  "variable": []
                },
                "method": "GET",
                "body": {}
              },
              "status": "Bad Request",
              "code": 400,
              "header": [
                {
                  "key": "Content-Type",
                  "value": "text/plain"
                }
              ],
              "body": "",
              "cookie": [],
              "_postman_previewlanguage": "text"
            },
            {
              "name": "No valid API token/key values have been provided with the request",
              "originalRequest": {
                "url": {
                  "path": [
                    "api",
                    "v2",
                    "readings"
                  ],
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "query": [
                    {
                      "key": "start",
                      "value": "{{start}}"
                    },
                    {
                      "key": "end",
                      "value": "{{end}}"
                    },
                    {
                      "key": "sort",
                      "value": "{{sort}}"
                    },
                    {
                      "key": "page",
                      "value": "{{page}}"
                    },
                    {
                      "key": "per",
                      "value": "{{per}}"
                    },
                    {
                      "key": "token",
                      "value": "{{token}}"
                    }
                  ],
                  "variable": []
                },
                "method": "GET",
                "body": {}
              },
              "status": "Unauthorized",
              "code": 401,
              "header": [
                {
                  "key": "Content-Type",
                  "value": "text/plain"
                }
              ],
              "body": "",
              "cookie": [],
              "_postman_previewlanguage": "text"
            }
          ],
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test postman-testplan using AI Type Azure Open AI and AI Model roostgpt-4-32k\n\n\nTest generated for api/v2/readings?start={{start}}&end={{end}}&sort={{sort}}&page={{page}}&per={{per}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n    responseData = pm.response.json();\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Readings for all Assets in the system with an Active or Disabled status\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            pm.response.to.have.header(\"Content-Type\");\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n        });\n        pm.test('Response has the `data` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data`)){\n                if(pm.expect(ld.get(pm.response.json(), `data`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data`, null)).to.equal(\"object\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.assets` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.assets`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.assets`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `data.assets`))).to.equal(true);\n                }\n\n            }\n\n        })\n  \n        pm.test(`data.assets length to be atmost '100'`,function(){\n            pm.expect(ld.get(responseData, `data.assets`, \"\").length).to.be.at.most(100);\n        })\n  \n        pm.test(`data.assets length to be atlease '100'`,function(){\n          pm.expect(ld.get(responseData, `data.assets`, \"\").length).to.be.at.least(0);\n        })\n\n        pm.test(`Each object in the data.assets field has all the required fields`,function(){\n            pm.expect(pm.response.json()).to.have.nested.property(`data.assets`);\n            let assetsArray = ld.get(pm.response.json(), `data.assets`, \"\");\n            for (let assets_it = 0; assets_it < assetsArray.length; assets_it++) {\n                let iterator = assets_it;\n                \t\n        pm.test(`${iterator} element of array 'data.assets[${assets_it}].1' has '1' as 'object'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `data.assets[${assets_it}].1`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`data.assets[${assets_it}].1`, null)).to.equal(\"object\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'data.assets[${assets_it}].1.sample_type' has 'sample_type' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `data.assets[${assets_it}].1.sample_type`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`data.assets[${assets_it}].1.sample_type`, null)).to.equal(\"string\");\n            }\n        })\n\n  \n        pm.test(`data.assets[${assets_it}].1.sample_type length to be atmost '1000'`,function(){\n            pm.expect(ld.get(responseData, `data.assets[${assets_it}].1.sample_type`, \"\").length).to.be.at.most(1000);\n        })\n  \n        pm.test(`data.assets[${assets_it}].1.sample_type length to be alteast '0'`,function(){\n            pm.expect(ld.get(responseData, `data.assets[${assets_it}].1.sample_type`, \"\").length).to.be.at.least(0);\n        })\n\n        pm.test(`${iterator} element of array 'data.assets[${assets_it}].1.units' has 'units' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `data.assets[${assets_it}].1.units`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`data.assets[${assets_it}].1.units`, null)).to.equal(\"string\");\n            }\n        })\n\n  \n        pm.test(`data.assets[${assets_it}].1.units length to be atmost '1000'`,function(){\n            pm.expect(ld.get(responseData, `data.assets[${assets_it}].1.units`, \"\").length).to.be.at.most(1000);\n        })\n  \n        pm.test(`data.assets[${assets_it}].1.units length to be alteast '0'`,function(){\n            pm.expect(ld.get(responseData, `data.assets[${assets_it}].1.units`, \"\").length).to.be.at.least(0);\n        })\n\n        pm.test(`${iterator} element of array 'assetsArray' has 'readings' as an array`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `data.assets[${assets_it}].1.readings`)).to.exist){\n              pm.expect(Array.isArray(ld.get(pm.response.json(), `data.assets[${assets_it}].1.readings`))).to.equal(true);\n            }\n\n        })\n\n  \n        pm.test(`data.assets[${assets_it}].1.readings length to be atmost '100'`,function(){\n            pm.expect(ld.get(responseData, `data.assets[${assets_it}].1.readings`, \"\").length).to.be.at.most(100);\n        })\n  \n        pm.test(`data.assets[${assets_it}].1.readings length to be atlease '100'`,function(){\n          pm.expect(ld.get(responseData, `data.assets[${assets_it}].1.readings`, \"\").length).to.be.at.least(0);\n        })\n\n        pm.test(`${iterator} element of array 'data.assets[${assets_it}].id' has 'id' as 'number'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `data.assets[${assets_it}].id`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`data.assets[${assets_it}].id`, null)).to.equal(\"number\");\n            }\n        })\n\n  \n        pm.expect(ld.get(pm.response.json(), `data.assets[${assets_it}].id`, \"\")).to.be.at.most(156073036.68364912);\n\n        pm.test(`${iterator} element of array 'data.assets[${assets_it}].name' has 'name' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `data.assets[${assets_it}].name`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`data.assets[${assets_it}].name`, null)).to.equal(\"string\");\n            }\n        })\n\n  \n        pm.test(`data.assets[${assets_it}].name length to be atmost '1000'`,function(){\n            pm.expect(ld.get(responseData, `data.assets[${assets_it}].name`, \"\").length).to.be.at.most(1000);\n        })\n  \n        pm.test(`data.assets[${assets_it}].name length to be alteast '0'`,function(){\n            pm.expect(ld.get(responseData, `data.assets[${assets_it}].name`, \"\").length).to.be.at.least(0);\n        })\n\n        pm.test(`${iterator} element of array 'data.assets[${assets_it}].tag' has 'tag' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `data.assets[${assets_it}].tag`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`data.assets[${assets_it}].tag`, null)).to.equal(\"string\");\n            }\n        })\n\n  \n        pm.test(`data.assets[${assets_it}].tag length to be atmost '1000'`,function(){\n            pm.expect(ld.get(responseData, `data.assets[${assets_it}].tag`, \"\").length).to.be.at.most(1000);\n        })\n  \n        pm.test(`data.assets[${assets_it}].tag length to be alteast '0'`,function(){\n            pm.expect(ld.get(responseData, `data.assets[${assets_it}].tag`, \"\").length).to.be.at.least(0);\n        })\n\n        pm.test(`${iterator} element of array 'data.assets[${assets_it}].state' has 'state' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `data.assets[${assets_it}].state`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`data.assets[${assets_it}].state`, null)).to.equal(\"string\");\n            }\n        })\n\n  \n        pm.test(`data.assets[${assets_it}].state length to be atmost '1000'`,function(){\n            pm.expect(ld.get(responseData, `data.assets[${assets_it}].state`, \"\").length).to.be.at.most(1000);\n        })\n  \n        pm.test(`data.assets[${assets_it}].state length to be alteast '0'`,function(){\n            pm.expect(ld.get(responseData, `data.assets[${assets_it}].state`, \"\").length).to.be.at.least(0);\n        })\n\n            }\n\n        })\n\n        pm.test('Response has the `errors` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`errors`)){\n                if(pm.expect(ld.get(pm.response.json(), `errors`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `errors`))).to.equal(true);\n                }\n\n            }\n\n        })\n  \n        pm.test(`errors length to be atmost '100'`,function(){\n            pm.expect(ld.get(responseData, `errors`, \"\").length).to.be.at.most(100);\n        })\n  \n        pm.test(`errors length to be atlease '100'`,function(){\n          pm.expect(ld.get(responseData, `errors`, \"\").length).to.be.at.least(0);\n        })\n\n    });\n\n}\n\nif (pm.response.code == 400){\n    pm.test(\"Invalid start or end parameter provided, or end provided without start\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"No valid API token/key values have been provided with the request\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    });\n\n}\n"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "protocolProfileBehavior": {
            "disableBodyPruning": true
          }
        },
        {
          "name": "assets",
          "item": [
            {
              "name": "/api/v2/assets",
              "request": {
                "name": "/api/v2/assets",
                "description": {},
                "url": {
                  "path": [
                    "api",
                    "v2",
                    "assets"
                  ],
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "query": [
                    {
                      "disabled": false,
                      "key": "sort",
                      "value": "{{sort}}",
                      "description": "\"The parameter with which to sort the highest level of items returned by the endpoint\"\n"
                    },
                    {
                      "disabled": false,
                      "key": "page",
                      "value": "{{page}}",
                      "description": "\"The page number of results to be loaded, e.g. page 3 of 5\" \\\n\"A valid 'per' parameter must be included if this parameter is used\"\n"
                    },
                    {
                      "disabled": false,
                      "key": "per",
                      "value": "{{per}}",
                      "description": "\"The number of results to load per page, e.g. 25 per page\" \\\n\"A valid 'page' parameter must be included if this parameter is used\"\n"
                    },
                    {
                      "disabled": false,
                      "key": "name",
                      "value": "{{name}}",
                      "description": "\"A string to filter returned assets on via their 'name' attribute\" \\\n\"e.g. a value of 'abc' would return all Assets with 'abc' in their name\"\n"
                    },
                    {
                      "disabled": false,
                      "key": "tag",
                      "value": "{{tag}}",
                      "description": "\"A string to filter returned assets on via their 'tag' attribute\" \\\n\"e.g. a value of 'abc' would return all Assets with 'abc' in their tag\"\n"
                    },
                    {
                      "disabled": false,
                      "key": "state",
                      "value": "{{state}}",
                      "description": "\"A string to filter returned assets on via their 'state' attribute\" \\\n\"Valid values are only 'enabled' or 'disabled'\"\n"
                    }
                  ],
                  "variable": []
                },
                "header": [
                  {
                    "key": "Accept",
                    "value": "application/json"
                  }
                ],
                "method": "GET",
                "auth": null
              },
              "response": [
                {
                  "name": "All Assets in the system with an Active or Distabled status",
                  "originalRequest": {
                    "url": {
                      "path": [
                        "api",
                        "v2",
                        "assets"
                      ],
                      "host": [
                        "{{baseUrl}}"
                      ],
                      "query": [
                        {
                          "key": "sort",
                          "value": "{{sort}}"
                        },
                        {
                          "key": "page",
                          "value": "{{page}}"
                        },
                        {
                          "key": "per",
                          "value": "{{per}}"
                        },
                        {
                          "key": "name",
                          "value": "{{name}}"
                        },
                        {
                          "key": "tag",
                          "value": "{{tag}}"
                        },
                        {
                          "key": "state",
                          "value": "{{state}}"
                        },
                        {
                          "key": "token",
                          "value": "{{token}}"
                        }
                      ],
                      "variable": []
                    },
                    "header": [
                      {
                        "key": "Accept",
                        "value": "application/json"
                      }
                    ],
                    "method": "GET",
                    "body": {}
                  },
                  "status": "OK",
                  "code": 200,
                  "header": [
                    {
                      "key": "Content-Type",
                      "value": "application/json"
                    }
                  ],
                  "body": "{\n  \"data\": [\n    {\n      \"id\": -4322413.698438793,\n      \"name\": \"exercitation sunt elit\",\n      \"tag\": \"laborum eiusmod quis nulla magna\",\n      \"state\": \"eu nulla mollit\"\n    },\n    {\n      \"id\": 22276585.310251698,\n      \"name\": \"proident anim\",\n      \"tag\": \"ut\",\n      \"state\": \"cillum quis sint\"\n    }\n  ],\n  \"errors\": [\n    \"officia ex\",\n    \"officia adipisicing dolore consequat\"\n  ]\n}",
                  "cookie": [],
                  "_postman_previewlanguage": "json"
                },
                {
                  "name": "No valid API token/key values have been provided with the request",
                  "originalRequest": {
                    "url": {
                      "path": [
                        "api",
                        "v2",
                        "assets"
                      ],
                      "host": [
                        "{{baseUrl}}"
                      ],
                      "query": [
                        {
                          "key": "sort",
                          "value": "{{sort}}"
                        },
                        {
                          "key": "page",
                          "value": "{{page}}"
                        },
                        {
                          "key": "per",
                          "value": "{{per}}"
                        },
                        {
                          "key": "name",
                          "value": "{{name}}"
                        },
                        {
                          "key": "tag",
                          "value": "{{tag}}"
                        },
                        {
                          "key": "state",
                          "value": "{{state}}"
                        },
                        {
                          "key": "token",
                          "value": "{{token}}"
                        }
                      ],
                      "variable": []
                    },
                    "method": "GET",
                    "body": {}
                  },
                  "status": "Unauthorized",
                  "code": 401,
                  "header": [
                    {
                      "key": "Content-Type",
                      "value": "text/plain"
                    }
                  ],
                  "body": "",
                  "cookie": [],
                  "_postman_previewlanguage": "text"
                }
              ],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "exec": [
                      " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test postman-testplan using AI Type Azure Open AI and AI Model roostgpt-4-32k\n\n\nTest generated for api/v2/assets?sort={{sort}}&page={{page}}&per={{per}}&name={{name}}&tag={{tag}}&state={{state}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n    responseData = pm.response.json();\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"All Assets in the system with an Active or Distabled status\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            pm.response.to.have.header(\"Content-Type\");\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n        });\n        pm.test('Response has the `data` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data`)){\n                if(pm.expect(ld.get(pm.response.json(), `data`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `data`))).to.equal(true);\n                }\n\n            }\n\n        })\n  \n        pm.test(`data length to be atmost '100'`,function(){\n            pm.expect(ld.get(responseData, `data`, \"\").length).to.be.at.most(100);\n        })\n  \n        pm.test(`data length to be atlease '100'`,function(){\n          pm.expect(ld.get(responseData, `data`, \"\").length).to.be.at.least(0);\n        })\n\n        pm.test(`Each object in the data field has all the required fields`,function(){\n            pm.expect(pm.response.json()).to.have.nested.property(`data`);\n            let dataArray = ld.get(pm.response.json(), `data`, \"\");\n            for (let data_it = 0; data_it < dataArray.length; data_it++) {\n                let iterator = data_it;\n                \t\n        pm.test(`${iterator} element of array 'data[${data_it}].id' has 'id' as 'number'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `data[${data_it}].id`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`data[${data_it}].id`, null)).to.equal(\"number\");\n            }\n        })\n\n  \n        pm.expect(ld.get(pm.response.json(), `data[${data_it}].id`, \"\")).to.be.at.least(-8644827.396877587);\n\n        pm.test(`${iterator} element of array 'data[${data_it}].name' has 'name' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `data[${data_it}].name`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`data[${data_it}].name`, null)).to.equal(\"string\");\n            }\n        })\n\n  \n        pm.test(`data[${data_it}].name length to be atmost '1000'`,function(){\n            pm.expect(ld.get(responseData, `data[${data_it}].name`, \"\").length).to.be.at.most(1000);\n        })\n  \n        pm.test(`data[${data_it}].name length to be alteast '0'`,function(){\n            pm.expect(ld.get(responseData, `data[${data_it}].name`, \"\").length).to.be.at.least(0);\n        })\n\n        pm.test(`${iterator} element of array 'data[${data_it}].tag' has 'tag' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `data[${data_it}].tag`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`data[${data_it}].tag`, null)).to.equal(\"string\");\n            }\n        })\n\n  \n        pm.test(`data[${data_it}].tag length to be atmost '1000'`,function(){\n            pm.expect(ld.get(responseData, `data[${data_it}].tag`, \"\").length).to.be.at.most(1000);\n        })\n  \n        pm.test(`data[${data_it}].tag length to be alteast '0'`,function(){\n            pm.expect(ld.get(responseData, `data[${data_it}].tag`, \"\").length).to.be.at.least(0);\n        })\n\n        pm.test(`${iterator} element of array 'data[${data_it}].state' has 'state' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `data[${data_it}].state`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`data[${data_it}].state`, null)).to.equal(\"string\");\n            }\n        })\n\n  \n        pm.test(`data[${data_it}].state length to be atmost '1000'`,function(){\n            pm.expect(ld.get(responseData, `data[${data_it}].state`, \"\").length).to.be.at.most(1000);\n        })\n  \n        pm.test(`data[${data_it}].state length to be alteast '0'`,function(){\n            pm.expect(ld.get(responseData, `data[${data_it}].state`, \"\").length).to.be.at.least(0);\n        })\n\n            }\n\n        })\n\n        pm.test('Response has the `errors` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`errors`)){\n                if(pm.expect(ld.get(pm.response.json(), `errors`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `errors`))).to.equal(true);\n                }\n\n            }\n\n        })\n  \n        pm.test(`errors length to be atmost '100'`,function(){\n            pm.expect(ld.get(responseData, `errors`, \"\").length).to.be.at.most(100);\n        })\n  \n        pm.test(`errors length to be atlease '100'`,function(){\n          pm.expect(ld.get(responseData, `errors`, \"\").length).to.be.at.least(0);\n        })\n\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"No valid API token/key values have been provided with the request\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    });\n\n}\n"
                    ],
                    "type": "text/javascript"
                  }
                }
              ],
              "protocolProfileBehavior": {
                "disableBodyPruning": true
              }
            },
            {
              "name": "{asset_id}",
              "item": [
                {
                  "name": "/api/v2/assets/:asset_id",
                  "request": {
                    "name": "/api/v2/assets/:asset_id",
                    "description": {},
                    "url": {
                      "path": [
                        "api",
                        "v2",
                        "assets",
                        ":asset_id"
                      ],
                      "host": [
                        "{{baseUrl}}"
                      ],
                      "query": [],
                      "variable": [
                        {
                          "disabled": false,
                          "type": "any",
                          "value": "{{asset_id}}",
                          "key": "asset_id",
                          "description": "(Required) \"The internal identifier of an Asset within the system\"\n"
                        }
                      ]
                    },
                    "header": [
                      {
                        "key": "Accept",
                        "value": "application/json"
                      }
                    ],
                    "method": "GET",
                    "auth": null
                  },
                  "response": [
                    {
                      "name": "Detailed information for a single Asset",
                      "originalRequest": {
                        "url": {
                          "path": [
                            "api",
                            "v2",
                            "assets",
                            ":asset_id"
                          ],
                          "host": [
                            "{{baseUrl}}"
                          ],
                          "query": [
                            {
                              "key": "token",
                              "value": "{{token}}"
                            }
                          ],
                          "variable": [
                            {
                              "disabled": false,
                              "type": "any",
                              "value": "{{asset_id}}",
                              "key": "asset_id",
                              "description": "(Required) \"The internal identifier of an Asset within the system\"\n"
                            }
                          ]
                        },
                        "header": [
                          {
                            "key": "Accept",
                            "value": "application/json"
                          }
                        ],
                        "method": "GET",
                        "body": {}
                      },
                      "status": "OK",
                      "code": 200,
                      "header": [
                        {
                          "key": "Content-Type",
                          "value": "application/json"
                        }
                      ],
                      "body": "{\n  \"data\": {\n    \"id\": 49944245.22339067,\n    \"name\": \"esse eiusmod pariatur\",\n    \"tag\": \"proident nostrud consequat ea\",\n    \"state\": \"occaecat veniam dolor est\",\n    \"description\": \"Ut\",\n    \"area\": \"officia aliquip tempor\",\n    \"sensor\": {\n      \"serial_number\": \"eu est nostrud ad deserunt\",\n      \"sensor_type\": \"est eiusmod sed\",\n      \"channels\": [\n        -97401586.1135491,\n        68188864.57609475\n      ],\n      \"asset\": {\n        \"id\": -64337855.92640042,\n        \"name\": \"enim laborum\",\n        \"tag\": \"adipisicing quis cillum\",\n        \"state\": \"eiusmod aliquip d\"\n      },\n      \"status\": {\n        \"signal_strength\": -53111158.068153806,\n        \"battery_level\": -1860513.367005974,\n        \"last_contact\": \"ullamco et Duis\"\n      }\n    }\n  },\n  \"errors\": [\n    \"Ut sed incididunt\",\n    \"ut nostrud incididunt deserunt nisi\"\n  ]\n}",
                      "cookie": [],
                      "_postman_previewlanguage": "json"
                    },
                    {
                      "name": "No valid API token/key values have been provided with the request",
                      "originalRequest": {
                        "url": {
                          "path": [
                            "api",
                            "v2",
                            "assets",
                            ":asset_id"
                          ],
                          "host": [
                            "{{baseUrl}}"
                          ],
                          "query": [
                            {
                              "key": "token",
                              "value": "{{token}}"
                            }
                          ],
                          "variable": [
                            {
                              "disabled": false,
                              "type": "any",
                              "value": "{{asset_id}}",
                              "key": "asset_id",
                              "description": "(Required) \"The internal identifier of an Asset within the system\"\n"
                            }
                          ]
                        },
                        "method": "GET",
                        "body": {}
                      },
                      "status": "Unauthorized",
                      "code": 401,
                      "header": [
                        {
                          "key": "Content-Type",
                          "value": "text/plain"
                        }
                      ],
                      "body": "",
                      "cookie": [],
                      "_postman_previewlanguage": "text"
                    }
                  ],
                  "event": [
                    {
                      "listen": "test",
                      "script": {
                        "exec": [
                          " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test postman-testplan using AI Type Azure Open AI and AI Model roostgpt-4-32k\n\n\nTest generated for api/v2/assets/{asset_id} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n    responseData = pm.response.json();\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Detailed information for a single Asset\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test('Response has the `data` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data`)){\n                if(pm.expect(ld.get(pm.response.json(), `data`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data`, null)).to.equal(\"object\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.id` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.id`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.id`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.id`, null)).to.equal(\"number\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.name` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.name`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.name`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.name`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.tag` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.tag`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.tag`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.tag`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.state` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.state`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.state`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.state`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.description` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.description`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.description`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.description`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.area` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.area`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.area`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.area`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.sensor` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.sensor`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.sensor`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.sensor`, null)).to.equal(\"object\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.sensor.serial_number` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.sensor.serial_number`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.sensor.serial_number`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.sensor.serial_number`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.sensor.sensor_type` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.sensor.sensor_type`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.sensor.sensor_type`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.sensor.sensor_type`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.sensor.channels` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.sensor.channels`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.sensor.channels`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `data.sensor.channels`))).to.equal(true);\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.sensor.asset` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.sensor.asset`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.sensor.asset`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.sensor.asset`, null)).to.equal(\"object\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.sensor.status` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.sensor.status`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.sensor.status`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.sensor.status`, null)).to.equal(\"object\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `errors` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`errors`)){\n                if(pm.expect(ld.get(pm.response.json(), `errors`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `errors`))).to.equal(true);\n                }\n\n            }\n\n        })\n\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"No valid API token/key values have been provided with the request\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    });\n\n}\n"
                        ],
                        "type": "text/javascript"
                      }
                    }
                  ],
                  "protocolProfileBehavior": {
                    "disableBodyPruning": true
                  }
                },
                {
                  "name": "/api/v2/assets/:asset_id/readings",
                  "request": {
                    "name": "/api/v2/assets/:asset_id/readings",
                    "description": {},
                    "url": {
                      "path": [
                        "api",
                        "v2",
                        "assets",
                        ":asset_id",
                        "readings"
                      ],
                      "host": [
                        "{{baseUrl}}"
                      ],
                      "query": [
                        {
                          "disabled": false,
                          "key": "start",
                          "value": "{{start}}",
                          "description": "\"The start datetime for the window of readings\" \\\n\"Readings before this datetime will not be included in the results\" \\\n\"If this parameter is not specified, the most recent reading for each Asset will be provided\"\n"
                        },
                        {
                          "disabled": false,
                          "key": "end",
                          "value": "{{end}}",
                          "description": "\"The end datetime for the window of readings\" \\\n\"Readings after this datetime will not be included in the results\" \\\n\"A valid 'start' parameter must be included if this parameter is used\"\n"
                        }
                      ],
                      "variable": [
                        {
                          "disabled": false,
                          "type": "any",
                          "value": "{{asset_id}}",
                          "key": "asset_id",
                          "description": "(Required) \"The internal identifier of an Asset within the system\"\n"
                        }
                      ]
                    },
                    "header": [
                      {
                        "key": "Accept",
                        "value": "application/json"
                      }
                    ],
                    "method": "GET",
                    "auth": null
                  },
                  "response": [
                    {
                      "name": "Readings for a single Asset",
                      "originalRequest": {
                        "url": {
                          "path": [
                            "api",
                            "v2",
                            "assets",
                            ":asset_id",
                            "readings"
                          ],
                          "host": [
                            "{{baseUrl}}"
                          ],
                          "query": [
                            {
                              "key": "start",
                              "value": "{{start}}"
                            },
                            {
                              "key": "end",
                              "value": "{{end}}"
                            },
                            {
                              "key": "token",
                              "value": "{{token}}"
                            }
                          ],
                          "variable": [
                            {
                              "disabled": false,
                              "type": "any",
                              "value": "{{asset_id}}",
                              "key": "asset_id",
                              "description": "(Required) \"The internal identifier of an Asset within the system\"\n"
                            }
                          ]
                        },
                        "header": [
                          {
                            "key": "Accept",
                            "value": "application/json"
                          }
                        ],
                        "method": "GET",
                        "body": {}
                      },
                      "status": "OK",
                      "code": 200,
                      "header": [
                        {
                          "key": "Content-Type",
                          "value": "application/json"
                        }
                      ],
                      "body": "{\n  \"data\": {\n    \"asset\": {\n      \"1\": {\n        \"sample_type\": \"ut sint do\",\n        \"units\": \"aute consequat laborum Excepteur\",\n        \"readings\": [\n          {\n            \"value\": 30129419.02943109,\n            \"time\": \"et velit qui\"\n          },\n          {\n            \"value\": -63670532.90159352,\n            \"time\": \"voluptate veniam laborum est\"\n          }\n        ]\n      },\n      \"id\": 82131979.39944378,\n      \"name\": \"exercitation\",\n      \"tag\": \"ipsum ullamco enim\",\n      \"state\": \"aliqua aliquip id\"\n    }\n  },\n  \"errors\": [\n    \"quis ad culpa magna\",\n    \"mollit anim dolor Excepteur\"\n  ]\n}",
                      "cookie": [],
                      "_postman_previewlanguage": "json"
                    },
                    {
                      "name": "No valid API token/key values have been provided with the request",
                      "originalRequest": {
                        "url": {
                          "path": [
                            "api",
                            "v2",
                            "assets",
                            ":asset_id",
                            "readings"
                          ],
                          "host": [
                            "{{baseUrl}}"
                          ],
                          "query": [
                            {
                              "key": "start",
                              "value": "{{start}}"
                            },
                            {
                              "key": "end",
                              "value": "{{end}}"
                            },
                            {
                              "key": "token",
                              "value": "{{token}}"
                            }
                          ],
                          "variable": [
                            {
                              "disabled": false,
                              "type": "any",
                              "value": "{{asset_id}}",
                              "key": "asset_id",
                              "description": "(Required) \"The internal identifier of an Asset within the system\"\n"
                            }
                          ]
                        },
                        "method": "GET",
                        "body": {}
                      },
                      "status": "Unauthorized",
                      "code": 401,
                      "header": [
                        {
                          "key": "Content-Type",
                          "value": "text/plain"
                        }
                      ],
                      "body": "",
                      "cookie": [],
                      "_postman_previewlanguage": "text"
                    }
                  ],
                  "event": [
                    {
                      "listen": "test",
                      "script": {
                        "exec": [
                          " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test postman-testplan using AI Type Azure Open AI and AI Model roostgpt-4-32k\n\n\nTest generated for api/v2/assets/{asset_id}/readings?start={{start}}&end={{end}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n    responseData = pm.response.json();\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Readings for a single Asset\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            pm.response.to.have.header(\"Content-Type\");\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n        });\n        pm.test('Response has the `data` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data`)){\n                if(pm.expect(ld.get(pm.response.json(), `data`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data`, null)).to.equal(\"object\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.asset` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.asset`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.asset`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.asset`, null)).to.equal(\"object\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.asset.1` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.asset.1`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.asset.1`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.asset.1`, null)).to.equal(\"object\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.asset.id` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.asset.id`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.asset.id`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.asset.id`, null)).to.equal(\"number\");\n                }\n\n            }\n\n        })\n  \n        pm.expect(ld.get(pm.response.json(), `data.asset.id`, \"\")).to.be.at.most(164263958.79888755);\n\n        pm.test('Response has the `data.asset.name` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.asset.name`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.asset.name`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.asset.name`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n  \n        pm.test(`data.asset.name length to be atmost '1000'`,function(){\n            pm.expect(ld.get(responseData, `data.asset.name`, \"\").length).to.be.at.most(1000);\n        })\n  \n        pm.test(`data.asset.name length to be alteast '0'`,function(){\n            pm.expect(ld.get(responseData, `data.asset.name`, \"\").length).to.be.at.least(0);\n        })\n\n        pm.test('Response has the `data.asset.tag` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.asset.tag`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.asset.tag`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.asset.tag`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n  \n        pm.test(`data.asset.tag length to be atmost '1000'`,function(){\n            pm.expect(ld.get(responseData, `data.asset.tag`, \"\").length).to.be.at.most(1000);\n        })\n  \n        pm.test(`data.asset.tag length to be alteast '0'`,function(){\n            pm.expect(ld.get(responseData, `data.asset.tag`, \"\").length).to.be.at.least(0);\n        })\n\n        pm.test('Response has the `data.asset.state` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.asset.state`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.asset.state`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.asset.state`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n  \n        pm.test(`data.asset.state length to be atmost '1000'`,function(){\n            pm.expect(ld.get(responseData, `data.asset.state`, \"\").length).to.be.at.most(1000);\n        })\n  \n        pm.test(`data.asset.state length to be alteast '0'`,function(){\n            pm.expect(ld.get(responseData, `data.asset.state`, \"\").length).to.be.at.least(0);\n        })\n\n        pm.test('Response has the `errors` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`errors`)){\n                if(pm.expect(ld.get(pm.response.json(), `errors`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `errors`))).to.equal(true);\n                }\n\n            }\n\n        })\n  \n        pm.test(`errors length to be atmost '100'`,function(){\n            pm.expect(ld.get(responseData, `errors`, \"\").length).to.be.at.most(100);\n        })\n  \n        pm.test(`errors length to be atlease '100'`,function(){\n          pm.expect(ld.get(responseData, `errors`, \"\").length).to.be.at.least(0);\n        })\n\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"No valid API token/key values have been provided with the request\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    });\n\n}\n"
                        ],
                        "type": "text/javascript"
                      }
                    }
                  ],
                  "protocolProfileBehavior": {
                    "disableBodyPruning": true
                  }
                },
                {
                  "name": "channels",
                  "item": [
                    {
                      "name": "/api/v2/assets/:asset_id/channels",
                      "request": {
                        "name": "/api/v2/assets/:asset_id/channels",
                        "description": {},
                        "url": {
                          "path": [
                            "api",
                            "v2",
                            "assets",
                            ":asset_id",
                            "channels"
                          ],
                          "host": [
                            "{{baseUrl}}"
                          ],
                          "query": [],
                          "variable": [
                            {
                              "disabled": false,
                              "type": "any",
                              "value": "{{asset_id}}",
                              "key": "asset_id",
                              "description": "(Required) \"The internal identifier of an Asset within the system\"\n"
                            }
                          ]
                        },
                        "header": [
                          {
                            "key": "Accept",
                            "value": "application/json"
                          }
                        ],
                        "method": "GET",
                        "auth": null
                      },
                      "response": [
                        {
                          "name": "Available channels/inputs for a single Asset",
                          "originalRequest": {
                            "url": {
                              "path": [
                                "api",
                                "v2",
                                "assets",
                                ":asset_id",
                                "channels"
                              ],
                              "host": [
                                "{{baseUrl}}"
                              ],
                              "query": [
                                {
                                  "key": "token",
                                  "value": "{{token}}"
                                }
                              ],
                              "variable": [
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{asset_id}}",
                                  "key": "asset_id",
                                  "description": "(Required) \"The internal identifier of an Asset within the system\"\n"
                                }
                              ]
                            },
                            "header": [
                              {
                                "key": "Accept",
                                "value": "application/json"
                              }
                            ],
                            "method": "GET",
                            "body": {}
                          },
                          "status": "OK",
                          "code": 200,
                          "header": [
                            {
                              "key": "Content-Type",
                              "value": "application/json"
                            }
                          ],
                          "body": "{\n  \"data\": {\n    \"channels\": [\n      -60140280.39677153,\n      -45590339.79123441\n    ]\n  },\n  \"errors\": [\n    \"commodo ullamco\",\n    \"non culpa pariatur ad\"\n  ]\n}",
                          "cookie": [],
                          "_postman_previewlanguage": "json"
                        },
                        {
                          "name": "No valid API token/key values have been provided with the request",
                          "originalRequest": {
                            "url": {
                              "path": [
                                "api",
                                "v2",
                                "assets",
                                ":asset_id",
                                "channels"
                              ],
                              "host": [
                                "{{baseUrl}}"
                              ],
                              "query": [
                                {
                                  "key": "token",
                                  "value": "{{token}}"
                                }
                              ],
                              "variable": [
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{asset_id}}",
                                  "key": "asset_id",
                                  "description": "(Required) \"The internal identifier of an Asset within the system\"\n"
                                }
                              ]
                            },
                            "method": "GET",
                            "body": {}
                          },
                          "status": "Unauthorized",
                          "code": 401,
                          "header": [
                            {
                              "key": "Content-Type",
                              "value": "text/plain"
                            }
                          ],
                          "body": "",
                          "cookie": [],
                          "_postman_previewlanguage": "text"
                        }
                      ],
                      "event": [
                        {
                          "listen": "test",
                          "script": {
                            "exec": [
                              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test postman-testplan using AI Type Azure Open AI and AI Model roostgpt-4-32k\n\n\nTest generated for api/v2/assets/{asset_id}/channels for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n    responseData = pm.response.json();\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Available channels/inputs for a single Asset\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test('Response has the `data` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data`)){\n                if(pm.expect(ld.get(pm.response.json(), `data`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data`, null)).to.equal(\"object\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.channels` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.channels`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.channels`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `data.channels`))).to.equal(true);\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `errors` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`errors`)){\n                if(pm.expect(ld.get(pm.response.json(), `errors`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `errors`))).to.equal(true);\n                }\n\n            }\n\n        })\n\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"No valid API token/key values have been provided with the request\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    });\n\n}\n"
                            ],
                            "type": "text/javascript"
                          }
                        }
                      ],
                      "protocolProfileBehavior": {
                        "disableBodyPruning": true
                      }
                    },
                    {
                      "name": "{channel_id}",
                      "item": [
                        {
                          "name": "/api/v2/assets/:asset_id/channels/:channel_id",
                          "request": {
                            "name": "/api/v2/assets/:asset_id/channels/:channel_id",
                            "description": {},
                            "url": {
                              "path": [
                                "api",
                                "v2",
                                "assets",
                                ":asset_id",
                                "channels",
                                ":channel_id"
                              ],
                              "host": [
                                "{{baseUrl}}"
                              ],
                              "query": [],
                              "variable": [
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{asset_id}}",
                                  "key": "asset_id",
                                  "description": "(Required) \"The internal identifier of an Asset within the system\"\n"
                                },
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{channel_id}}",
                                  "key": "channel_id",
                                  "description": "(Required) \"The identifier of the channel/input for a given Asset or Sensor\" \\\n\"Must be a value between 1 and 3, with 3 always being a binary channel/input\"\n"
                                }
                              ]
                            },
                            "header": [
                              {
                                "key": "Accept",
                                "value": "application/json"
                              }
                            ],
                            "method": "GET",
                            "auth": null
                          },
                          "response": [
                            {
                              "name": "Detailed channel/input information for a single Asset",
                              "originalRequest": {
                                "url": {
                                  "path": [
                                    "api",
                                    "v2",
                                    "assets",
                                    ":asset_id",
                                    "channels",
                                    ":channel_id"
                                  ],
                                  "host": [
                                    "{{baseUrl}}"
                                  ],
                                  "query": [
                                    {
                                      "key": "token",
                                      "value": "{{token}}"
                                    }
                                  ],
                                  "variable": [
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "{{asset_id}}",
                                      "key": "asset_id",
                                      "description": "(Required) \"The internal identifier of an Asset within the system\"\n"
                                    },
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "{{channel_id}}",
                                      "key": "channel_id",
                                      "description": "(Required) \"The identifier of the channel/input for a given Asset or Sensor\" \\\n\"Must be a value between 1 and 3, with 3 always being a binary channel/input\"\n"
                                    }
                                  ]
                                },
                                "header": [
                                  {
                                    "key": "Accept",
                                    "value": "application/json"
                                  }
                                ],
                                "method": "GET",
                                "body": {}
                              },
                              "status": "OK",
                              "code": 200,
                              "header": [
                                {
                                  "key": "Content-Type",
                                  "value": "application/json"
                                }
                              ],
                              "body": "{\n  \"data\": {\n    \"sample_type\": \"est Duis\",\n    \"units\": \"ut enim\",\n    \"alarm_limits\": [\n      {\n        \"name\": \"magna anim cupidatat laborum Ut\",\n        \"enabled\": \"sed\",\n        \"type\": \"nisi officia nulla\",\n        \"threshold_time\": -62318410.27327072,\n        \"min\": \"in nostrud qui\",\n        \"max\": \"eu laboris elit ut\"\n      },\n      {\n        \"name\": \"ex aliquip in proident nulla\",\n        \"enabled\": \"adipisicing amet Duis officia\",\n        \"type\": \"consectetur\",\n        \"threshold_time\": -22889949.621544823,\n        \"min\": \"ad laborum eiusmod Lorem\",\n        \"max\": \"in ad fugiat\"\n      }\n    ]\n  },\n  \"errors\": [\n    \"voluptate enim\",\n    \"anim\"\n  ]\n}",
                              "cookie": [],
                              "_postman_previewlanguage": "json"
                            },
                            {
                              "name": "No valid API token/key values have been provided with the request",
                              "originalRequest": {
                                "url": {
                                  "path": [
                                    "api",
                                    "v2",
                                    "assets",
                                    ":asset_id",
                                    "channels",
                                    ":channel_id"
                                  ],
                                  "host": [
                                    "{{baseUrl}}"
                                  ],
                                  "query": [
                                    {
                                      "key": "token",
                                      "value": "{{token}}"
                                    }
                                  ],
                                  "variable": [
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "{{asset_id}}",
                                      "key": "asset_id",
                                      "description": "(Required) \"The internal identifier of an Asset within the system\"\n"
                                    },
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "{{channel_id}}",
                                      "key": "channel_id",
                                      "description": "(Required) \"The identifier of the channel/input for a given Asset or Sensor\" \\\n\"Must be a value between 1 and 3, with 3 always being a binary channel/input\"\n"
                                    }
                                  ]
                                },
                                "method": "GET",
                                "body": {}
                              },
                              "status": "Unauthorized",
                              "code": 401,
                              "header": [
                                {
                                  "key": "Content-Type",
                                  "value": "text/plain"
                                }
                              ],
                              "body": "",
                              "cookie": [],
                              "_postman_previewlanguage": "text"
                            }
                          ],
                          "event": [
                            {
                              "listen": "test",
                              "script": {
                                "exec": [
                                  " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test postman-testplan using AI Type Azure Open AI and AI Model roostgpt-4-32k\n\n\nTest generated for api/v2/assets/{asset_id}/channels/{channel_id} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n    responseData = pm.response.json();\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Detailed channel/input information for a single Asset\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test('Response has the `data` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data`)){\n                if(pm.expect(ld.get(pm.response.json(), `data`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data`, null)).to.equal(\"object\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.sample_type` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.sample_type`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.sample_type`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.sample_type`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.units` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.units`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.units`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.units`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.alarm_limits` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.alarm_limits`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.alarm_limits`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `data.alarm_limits`))).to.equal(true);\n                }\n\n            }\n\n        })\n\n        pm.test(`Each object in the data.alarm_limits field has all the required fields`,function(){\n            pm.expect(pm.response.json()).to.have.nested.property(`data.alarm_limits`);\n            let alarm_limitsArray = ld.get(pm.response.json(), `data.alarm_limits`, \"\");\n            for (let alarm_limits_it = 0; alarm_limits_it < alarm_limitsArray.length; alarm_limits_it++) {\n                let iterator = alarm_limits_it;\n                \t\n        pm.test(`${iterator} element of array 'data.alarm_limits[${alarm_limits_it}].name' has 'name' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `data.alarm_limits[${alarm_limits_it}].name`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`data.alarm_limits[${alarm_limits_it}].name`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'data.alarm_limits[${alarm_limits_it}].enabled' has 'enabled' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `data.alarm_limits[${alarm_limits_it}].enabled`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`data.alarm_limits[${alarm_limits_it}].enabled`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'data.alarm_limits[${alarm_limits_it}].type' has 'type' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `data.alarm_limits[${alarm_limits_it}].type`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`data.alarm_limits[${alarm_limits_it}].type`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'data.alarm_limits[${alarm_limits_it}].threshold_time' has 'threshold_time' as 'number'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `data.alarm_limits[${alarm_limits_it}].threshold_time`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`data.alarm_limits[${alarm_limits_it}].threshold_time`, null)).to.equal(\"number\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'data.alarm_limits[${alarm_limits_it}].min' has 'min' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `data.alarm_limits[${alarm_limits_it}].min`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`data.alarm_limits[${alarm_limits_it}].min`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'data.alarm_limits[${alarm_limits_it}].max' has 'max' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `data.alarm_limits[${alarm_limits_it}].max`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`data.alarm_limits[${alarm_limits_it}].max`, null)).to.equal(\"string\");\n            }\n        })\n\n\n            }\n\n        })\n\n        pm.test('Response has the `errors` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`errors`)){\n                if(pm.expect(ld.get(pm.response.json(), `errors`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `errors`))).to.equal(true);\n                }\n\n            }\n\n        })\n\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"No valid API token/key values have been provided with the request\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    });\n\n}\n"
                                ],
                                "type": "text/javascript"
                              }
                            }
                          ],
                          "protocolProfileBehavior": {
                            "disableBodyPruning": true
                          }
                        },
                        {
                          "name": "/api/v2/assets/:asset_id/channels/:channel_id/readings",
                          "request": {
                            "name": "/api/v2/assets/:asset_id/channels/:channel_id/readings",
                            "description": {},
                            "url": {
                              "path": [
                                "api",
                                "v2",
                                "assets",
                                ":asset_id",
                                "channels",
                                ":channel_id",
                                "readings"
                              ],
                              "host": [
                                "{{baseUrl}}"
                              ],
                              "query": [
                                {
                                  "disabled": false,
                                  "key": "start",
                                  "value": "{{start}}",
                                  "description": "\"The start datetime for the window of readings\" \\\n\"Readings before this datetime will not be included in the results\" \\\n\"If this parameter is not specified, the most recent reading for each Asset will be provided\"\n"
                                },
                                {
                                  "disabled": false,
                                  "key": "end",
                                  "value": "{{end}}",
                                  "description": "\"The end datetime for the window of readings\" \\\n\"Readings after this datetime will not be included in the results\" \\\n\"A valid 'start' parameter must be included if this parameter is used\"\n"
                                }
                              ],
                              "variable": [
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{asset_id}}",
                                  "key": "asset_id",
                                  "description": "(Required) \"The internal identifier of an Asset within the system\"\n"
                                },
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{channel_id}}",
                                  "key": "channel_id",
                                  "description": "(Required) \"The identifier of the channel/input for a given Asset or Sensor\" \\\n\"Must be a value between 1 and 3, with 3 always being a binary channel/input\"\n"
                                }
                              ]
                            },
                            "header": [
                              {
                                "key": "Accept",
                                "value": "application/json"
                              }
                            ],
                            "method": "GET",
                            "auth": null
                          },
                          "response": [
                            {
                              "name": "Readings for a single channel/input for a single Asset",
                              "originalRequest": {
                                "url": {
                                  "path": [
                                    "api",
                                    "v2",
                                    "assets",
                                    ":asset_id",
                                    "channels",
                                    ":channel_id",
                                    "readings"
                                  ],
                                  "host": [
                                    "{{baseUrl}}"
                                  ],
                                  "query": [
                                    {
                                      "key": "start",
                                      "value": "{{start}}"
                                    },
                                    {
                                      "key": "end",
                                      "value": "{{end}}"
                                    },
                                    {
                                      "key": "token",
                                      "value": "{{token}}"
                                    }
                                  ],
                                  "variable": [
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "{{asset_id}}",
                                      "key": "asset_id",
                                      "description": "(Required) \"The internal identifier of an Asset within the system\"\n"
                                    },
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "{{channel_id}}",
                                      "key": "channel_id",
                                      "description": "(Required) \"The identifier of the channel/input for a given Asset or Sensor\" \\\n\"Must be a value between 1 and 3, with 3 always being a binary channel/input\"\n"
                                    }
                                  ]
                                },
                                "header": [
                                  {
                                    "key": "Accept",
                                    "value": "application/json"
                                  }
                                ],
                                "method": "GET",
                                "body": {}
                              },
                              "status": "OK",
                              "code": 200,
                              "header": [
                                {
                                  "key": "Content-Type",
                                  "value": "application/json"
                                }
                              ],
                              "body": "{\n  \"data\": {\n    \"1\": {\n      \"sample_type\": \"ea elit anim\",\n      \"units\": \"reprehenderit culpa\",\n      \"readings\": [\n        {\n          \"value\": 21805136.80471787,\n          \"time\": \"nostrud incididunt id\"\n        },\n        {\n          \"value\": -33774785.348485835,\n          \"time\": \"sunt dolor Lorem\"\n        }\n      ]\n    }\n  },\n  \"errors\": [\n    \"nostrud Ut Lorem labore\",\n    \"sint labore\"\n  ]\n}",
                              "cookie": [],
                              "_postman_previewlanguage": "json"
                            },
                            {
                              "name": "No valid API token/key values have been provided with the request",
                              "originalRequest": {
                                "url": {
                                  "path": [
                                    "api",
                                    "v2",
                                    "assets",
                                    ":asset_id",
                                    "channels",
                                    ":channel_id",
                                    "readings"
                                  ],
                                  "host": [
                                    "{{baseUrl}}"
                                  ],
                                  "query": [
                                    {
                                      "key": "start",
                                      "value": "{{start}}"
                                    },
                                    {
                                      "key": "end",
                                      "value": "{{end}}"
                                    },
                                    {
                                      "key": "token",
                                      "value": "{{token}}"
                                    }
                                  ],
                                  "variable": [
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "{{asset_id}}",
                                      "key": "asset_id",
                                      "description": "(Required) \"The internal identifier of an Asset within the system\"\n"
                                    },
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "{{channel_id}}",
                                      "key": "channel_id",
                                      "description": "(Required) \"The identifier of the channel/input for a given Asset or Sensor\" \\\n\"Must be a value between 1 and 3, with 3 always being a binary channel/input\"\n"
                                    }
                                  ]
                                },
                                "method": "GET",
                                "body": {}
                              },
                              "status": "Unauthorized",
                              "code": 401,
                              "header": [
                                {
                                  "key": "Content-Type",
                                  "value": "text/plain"
                                }
                              ],
                              "body": "",
                              "cookie": [],
                              "_postman_previewlanguage": "text"
                            }
                          ],
                          "event": [
                            {
                              "listen": "test",
                              "script": {
                                "exec": [
                                  " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test postman-testplan using AI Type Azure Open AI and AI Model roostgpt-4-32k\n\n\nTest generated for api/v2/assets/{asset_id}/channels/{channel_id}/readings?start={{start}}&end={{end}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n    responseData = pm.response.json();\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Readings for a single channel/input for a single Asset\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            pm.response.to.have.header(\"Content-Type\");\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n        });\n        pm.test('Response has the `data` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data`)){\n                if(pm.expect(ld.get(pm.response.json(), `data`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data`, null)).to.equal(\"object\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.1` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.1`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.1`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.1`, null)).to.equal(\"object\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.1.sample_type` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.1.sample_type`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.1.sample_type`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.1.sample_type`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n  \n        pm.test(`data.1.sample_type length to be atmost '1000'`,function(){\n            pm.expect(ld.get(responseData, `data.1.sample_type`, \"\").length).to.be.at.most(1000);\n        })\n  \n        pm.test(`data.1.sample_type length to be alteast '0'`,function(){\n            pm.expect(ld.get(responseData, `data.1.sample_type`, \"\").length).to.be.at.least(0);\n        })\n\n        pm.test('Response has the `data.1.units` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.1.units`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.1.units`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.1.units`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n  \n        pm.test(`data.1.units length to be atmost '1000'`,function(){\n            pm.expect(ld.get(responseData, `data.1.units`, \"\").length).to.be.at.most(1000);\n        })\n  \n        pm.test(`data.1.units length to be alteast '0'`,function(){\n            pm.expect(ld.get(responseData, `data.1.units`, \"\").length).to.be.at.least(0);\n        })\n\n        pm.test('Response has the `data.1.readings` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.1.readings`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.1.readings`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `data.1.readings`))).to.equal(true);\n                }\n\n            }\n\n        })\n  \n        pm.test(`data.1.readings length to be atmost '100'`,function(){\n            pm.expect(ld.get(responseData, `data.1.readings`, \"\").length).to.be.at.most(100);\n        })\n  \n        pm.test(`data.1.readings length to be atlease '100'`,function(){\n          pm.expect(ld.get(responseData, `data.1.readings`, \"\").length).to.be.at.least(0);\n        })\n\n        pm.test(`Each object in the data.1.readings field has all the required fields`,function(){\n            pm.expect(pm.response.json()).to.have.nested.property(`data.1.readings`);\n            let readingsArray = ld.get(pm.response.json(), `data.1.readings`, \"\");\n            for (let readings_it = 0; readings_it < readingsArray.length; readings_it++) {\n                let iterator = readings_it;\n                \t\n        pm.test(`${iterator} element of array 'data.1.readings[${readings_it}].value' has 'value' as 'number'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `data.1.readings[${readings_it}].value`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`data.1.readings[${readings_it}].value`, null)).to.equal(\"number\");\n            }\n        })\n\n  \n        pm.expect(ld.get(pm.response.json(), `data.1.readings[${readings_it}].value`, \"\")).to.be.at.most(43610273.60943574);\n\n        pm.test(`${iterator} element of array 'data.1.readings[${readings_it}].time' has 'time' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `data.1.readings[${readings_it}].time`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`data.1.readings[${readings_it}].time`, null)).to.equal(\"string\");\n            }\n        })\n\n  \n        pm.test(`data.1.readings[${readings_it}].time length to be atmost '1000'`,function(){\n            pm.expect(ld.get(responseData, `data.1.readings[${readings_it}].time`, \"\").length).to.be.at.most(1000);\n        })\n  \n        pm.test(`data.1.readings[${readings_it}].time length to be alteast '0'`,function(){\n            pm.expect(ld.get(responseData, `data.1.readings[${readings_it}].time`, \"\").length).to.be.at.least(0);\n        })\n\n            }\n\n        })\n\n        pm.test('Response has the `errors` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`errors`)){\n                if(pm.expect(ld.get(pm.response.json(), `errors`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `errors`))).to.equal(true);\n                }\n\n            }\n\n        })\n  \n        pm.test(`errors length to be atmost '100'`,function(){\n            pm.expect(ld.get(responseData, `errors`, \"\").length).to.be.at.most(100);\n        })\n  \n        pm.test(`errors length to be atlease '100'`,function(){\n          pm.expect(ld.get(responseData, `errors`, \"\").length).to.be.at.least(0);\n        })\n\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"No valid API token/key values have been provided with the request\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    });\n\n}\n"
                                ],
                                "type": "text/javascript"
                              }
                            }
                          ],
                          "protocolProfileBehavior": {
                            "disableBodyPruning": true
                          }
                        }
                      ],
                      "event": []
                    }
                  ],
                  "event": []
                }
              ],
              "event": []
            }
          ],
          "event": []
        },
        {
          "name": "sensors",
          "item": [
            {
              "name": "/api/v2/sensors",
              "request": {
                "name": "/api/v2/sensors",
                "description": {},
                "url": {
                  "path": [
                    "api",
                    "v2",
                    "sensors"
                  ],
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "query": [
                    {
                      "disabled": false,
                      "key": "sort",
                      "value": "{{sort}}",
                      "description": "\"The parameter with which to sort the highest level of items returned by the endpoint\"\n"
                    },
                    {
                      "disabled": false,
                      "key": "page",
                      "value": "{{page}}",
                      "description": "\"The page number of results to be loaded, e.g. page 3 of 5\" \\\n\"A valid 'per' parameter must be included if this parameter is used\"\n"
                    },
                    {
                      "disabled": false,
                      "key": "per",
                      "value": "{{per}}",
                      "description": "\"The number of results to load per page, e.g. 25 per page\" \\\n\"A valid 'page' parameter must be included if this parameter is used\"\n"
                    }
                  ],
                  "variable": []
                },
                "header": [
                  {
                    "key": "Accept",
                    "value": "application/json"
                  }
                ],
                "method": "GET",
                "auth": null
              },
              "response": [
                {
                  "name": "All Sensors in the system",
                  "originalRequest": {
                    "url": {
                      "path": [
                        "api",
                        "v2",
                        "sensors"
                      ],
                      "host": [
                        "{{baseUrl}}"
                      ],
                      "query": [
                        {
                          "key": "sort",
                          "value": "{{sort}}"
                        },
                        {
                          "key": "page",
                          "value": "{{page}}"
                        },
                        {
                          "key": "per",
                          "value": "{{per}}"
                        },
                        {
                          "key": "token",
                          "value": "{{token}}"
                        }
                      ],
                      "variable": []
                    },
                    "header": [
                      {
                        "key": "Accept",
                        "value": "application/json"
                      }
                    ],
                    "method": "GET",
                    "body": {}
                  },
                  "status": "OK",
                  "code": 200,
                  "header": [
                    {
                      "key": "Content-Type",
                      "value": "application/json"
                    }
                  ],
                  "body": "{\n  \"data\": [\n    {\n      \"serial_number\": \"amet\",\n      \"sensor_type\": \"labore ullamco ea reprehenderit quis\",\n      \"channels\": [\n        \"incididunt aliq\",\n        \"fugiat sed dolore\"\n      ]\n    },\n    {\n      \"serial_number\": \"exercitation\",\n      \"sensor_type\": \"magna elit Excepteur consectetur\",\n      \"channels\": [\n        \"dolore culpa nulla\",\n        \"aute occaecat\"\n      ]\n    }\n  ],\n  \"errors\": [\n    \"eiusm\",\n    \"est laborum\"\n  ]\n}",
                  "cookie": [],
                  "_postman_previewlanguage": "json"
                },
                {
                  "name": "No valid API token/key values have been provided with the request",
                  "originalRequest": {
                    "url": {
                      "path": [
                        "api",
                        "v2",
                        "sensors"
                      ],
                      "host": [
                        "{{baseUrl}}"
                      ],
                      "query": [
                        {
                          "key": "sort",
                          "value": "{{sort}}"
                        },
                        {
                          "key": "page",
                          "value": "{{page}}"
                        },
                        {
                          "key": "per",
                          "value": "{{per}}"
                        },
                        {
                          "key": "token",
                          "value": "{{token}}"
                        }
                      ],
                      "variable": []
                    },
                    "method": "GET",
                    "body": {}
                  },
                  "status": "Unauthorized",
                  "code": 401,
                  "header": [
                    {
                      "key": "Content-Type",
                      "value": "text/plain"
                    }
                  ],
                  "body": "",
                  "cookie": [],
                  "_postman_previewlanguage": "text"
                }
              ],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "exec": [
                      " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test postman-testplan using AI Type Azure Open AI and AI Model roostgpt-4-32k\n\n\nTest generated for api/v2/sensors?sort={{sort}}&page={{page}}&per={{per}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n    responseData = pm.response.json();\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"All Sensors in the system\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            pm.response.to.have.header(\"Content-Type\");\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n        });\n        pm.test('Response has the `data` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data`)){\n                if(pm.expect(ld.get(pm.response.json(), `data`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `data`))).to.equal(true);\n                }\n\n            }\n\n        })\n  \n        pm.test(`data length to be atmost '100'`,function(){\n            pm.expect(ld.get(responseData, `data`, \"\").length).to.be.at.most(100);\n        })\n  \n        pm.test(`data length to be atlease '100'`,function(){\n          pm.expect(ld.get(responseData, `data`, \"\").length).to.be.at.least(0);\n        })\n\n        pm.test(`Each object in the data field has all the required fields`,function(){\n            pm.expect(pm.response.json()).to.have.nested.property(`data`);\n            let dataArray = ld.get(pm.response.json(), `data`, \"\");\n            for (let data_it = 0; data_it < dataArray.length; data_it++) {\n                let iterator = data_it;\n                \t\n        pm.test(`${iterator} element of array 'data[${data_it}].serial_number' has 'serial_number' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `data[${data_it}].serial_number`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`data[${data_it}].serial_number`, null)).to.equal(\"string\");\n            }\n        })\n\n  \n        pm.test(`data[${data_it}].serial_number length to be atmost '1000'`,function(){\n            pm.expect(ld.get(responseData, `data[${data_it}].serial_number`, \"\").length).to.be.at.most(1000);\n        })\n  \n        pm.test(`data[${data_it}].serial_number length to be alteast '0'`,function(){\n            pm.expect(ld.get(responseData, `data[${data_it}].serial_number`, \"\").length).to.be.at.least(0);\n        })\n\n        pm.test(`${iterator} element of array 'data[${data_it}].sensor_type' has 'sensor_type' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `data[${data_it}].sensor_type`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`data[${data_it}].sensor_type`, null)).to.equal(\"string\");\n            }\n        })\n\n  \n        pm.test(`data[${data_it}].sensor_type length to be atmost '1000'`,function(){\n            pm.expect(ld.get(responseData, `data[${data_it}].sensor_type`, \"\").length).to.be.at.most(1000);\n        })\n  \n        pm.test(`data[${data_it}].sensor_type length to be alteast '0'`,function(){\n            pm.expect(ld.get(responseData, `data[${data_it}].sensor_type`, \"\").length).to.be.at.least(0);\n        })\n\n        pm.test(`${iterator} element of array 'dataArray' has 'channels' as an array`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `data[${data_it}].channels`)).to.exist){\n              pm.expect(Array.isArray(ld.get(pm.response.json(), `data[${data_it}].channels`))).to.equal(true);\n            }\n\n        })\n\n  \n        pm.test(`data[${data_it}].channels length to be atmost '100'`,function(){\n            pm.expect(ld.get(responseData, `data[${data_it}].channels`, \"\").length).to.be.at.most(100);\n        })\n  \n        pm.test(`data[${data_it}].channels length to be atlease '100'`,function(){\n          pm.expect(ld.get(responseData, `data[${data_it}].channels`, \"\").length).to.be.at.least(0);\n        })\n\n            }\n\n        })\n\n        pm.test('Response has the `errors` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`errors`)){\n                if(pm.expect(ld.get(pm.response.json(), `errors`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `errors`))).to.equal(true);\n                }\n\n            }\n\n        })\n  \n        pm.test(`errors length to be atmost '100'`,function(){\n            pm.expect(ld.get(responseData, `errors`, \"\").length).to.be.at.most(100);\n        })\n  \n        pm.test(`errors length to be atlease '100'`,function(){\n          pm.expect(ld.get(responseData, `errors`, \"\").length).to.be.at.least(0);\n        })\n\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"No valid API token/key values have been provided with the request\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    });\n\n}\n"
                    ],
                    "type": "text/javascript"
                  }
                }
              ],
              "protocolProfileBehavior": {
                "disableBodyPruning": true
              }
            },
            {
              "name": "{sensor_id}",
              "item": [
                {
                  "name": "/api/v2/sensors/:sensor_id",
                  "request": {
                    "name": "/api/v2/sensors/:sensor_id",
                    "description": {},
                    "url": {
                      "path": [
                        "api",
                        "v2",
                        "sensors",
                        ":sensor_id"
                      ],
                      "host": [
                        "{{baseUrl}}"
                      ],
                      "query": [],
                      "variable": [
                        {
                          "disabled": false,
                          "type": "any",
                          "value": "{{sensor_id}}",
                          "key": "sensor_id",
                          "description": "(Required) \"The Serial Number of a Sensor, 8 hexadecimal characters long\"\n"
                        }
                      ]
                    },
                    "header": [
                      {
                        "key": "Accept",
                        "value": "application/json"
                      }
                    ],
                    "method": "GET",
                    "auth": null
                  },
                  "response": [
                    {
                      "name": "Detailed information for a single Sensor",
                      "originalRequest": {
                        "url": {
                          "path": [
                            "api",
                            "v2",
                            "sensors",
                            ":sensor_id"
                          ],
                          "host": [
                            "{{baseUrl}}"
                          ],
                          "query": [
                            {
                              "key": "token",
                              "value": "{{token}}"
                            }
                          ],
                          "variable": [
                            {
                              "disabled": false,
                              "type": "any",
                              "value": "{{sensor_id}}",
                              "key": "sensor_id",
                              "description": "(Required) \"The Serial Number of a Sensor, 8 hexadecimal characters long\"\n"
                            }
                          ]
                        },
                        "header": [
                          {
                            "key": "Accept",
                            "value": "application/json"
                          }
                        ],
                        "method": "GET",
                        "body": {}
                      },
                      "status": "OK",
                      "code": 200,
                      "header": [
                        {
                          "key": "Content-Type",
                          "value": "application/json"
                        }
                      ],
                      "body": "{\n  \"data\": {\n    \"serial_number\": \"Lorem\",\n    \"sensor_type\": \"ex proident dolor\",\n    \"channels\": [\n      94898678.02196535,\n      -65410622.64814388\n    ],\n    \"asset\": {\n      \"id\": 54944167.97276232,\n      \"name\": \"ut in\",\n      \"tag\": \"in qui\",\n      \"state\": \"in et consecte\"\n    },\n    \"status\": {\n      \"signal_strength\": -2437138.605660662,\n      \"battery_level\": 32430557.340527087,\n      \"last_contact\": \"voluptate exercitation\"\n    }\n  },\n  \"errors\": [\n    \"labore in\",\n    \"dolore non occaecat Lo\"\n  ]\n}",
                      "cookie": [],
                      "_postman_previewlanguage": "json"
                    },
                    {
                      "name": "No valid API token/key values have been provided with the request",
                      "originalRequest": {
                        "url": {
                          "path": [
                            "api",
                            "v2",
                            "sensors",
                            ":sensor_id"
                          ],
                          "host": [
                            "{{baseUrl}}"
                          ],
                          "query": [
                            {
                              "key": "token",
                              "value": "{{token}}"
                            }
                          ],
                          "variable": [
                            {
                              "disabled": false,
                              "type": "any",
                              "value": "{{sensor_id}}",
                              "key": "sensor_id",
                              "description": "(Required) \"The Serial Number of a Sensor, 8 hexadecimal characters long\"\n"
                            }
                          ]
                        },
                        "method": "GET",
                        "body": {}
                      },
                      "status": "Unauthorized",
                      "code": 401,
                      "header": [
                        {
                          "key": "Content-Type",
                          "value": "text/plain"
                        }
                      ],
                      "body": "",
                      "cookie": [],
                      "_postman_previewlanguage": "text"
                    }
                  ],
                  "event": [
                    {
                      "listen": "test",
                      "script": {
                        "exec": [
                          " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test postman-testplan using AI Type Azure Open AI and AI Model roostgpt-4-32k\n\n\nTest generated for api/v2/sensors/{sensor_id} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n    responseData = pm.response.json();\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Detailed information for a single Sensor\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test('Response has the `data` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data`)){\n                if(pm.expect(ld.get(pm.response.json(), `data`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data`, null)).to.equal(\"object\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.serial_number` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.serial_number`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.serial_number`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.serial_number`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.sensor_type` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.sensor_type`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.sensor_type`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.sensor_type`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.channels` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.channels`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.channels`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `data.channels`))).to.equal(true);\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.asset` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.asset`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.asset`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.asset`, null)).to.equal(\"object\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.asset.id` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.asset.id`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.asset.id`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.asset.id`, null)).to.equal(\"number\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.asset.name` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.asset.name`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.asset.name`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.asset.name`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.asset.tag` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.asset.tag`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.asset.tag`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.asset.tag`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.asset.state` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.asset.state`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.asset.state`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.asset.state`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.status` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.status`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.status`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.status`, null)).to.equal(\"object\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.status.signal_strength` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.status.signal_strength`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.status.signal_strength`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.status.signal_strength`, null)).to.equal(\"number\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.status.battery_level` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.status.battery_level`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.status.battery_level`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.status.battery_level`, null)).to.equal(\"number\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.status.last_contact` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.status.last_contact`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.status.last_contact`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.status.last_contact`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `errors` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`errors`)){\n                if(pm.expect(ld.get(pm.response.json(), `errors`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `errors`))).to.equal(true);\n                }\n\n            }\n\n        })\n\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"No valid API token/key values have been provided with the request\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    });\n\n}\n"
                        ],
                        "type": "text/javascript"
                      }
                    }
                  ],
                  "protocolProfileBehavior": {
                    "disableBodyPruning": true
                  }
                },
                {
                  "name": "/api/v2/sensors/:sensor_id/readings",
                  "request": {
                    "name": "/api/v2/sensors/:sensor_id/readings",
                    "description": {},
                    "url": {
                      "path": [
                        "api",
                        "v2",
                        "sensors",
                        ":sensor_id",
                        "readings"
                      ],
                      "host": [
                        "{{baseUrl}}"
                      ],
                      "query": [
                        {
                          "disabled": false,
                          "key": "start",
                          "value": "{{start}}",
                          "description": "\"The start datetime for the window of readings\" \\\n\"Readings before this datetime will not be included in the results\" \\\n\"If this parameter is not specified, the most recent reading for each Asset will be provided\"\n"
                        },
                        {
                          "disabled": false,
                          "key": "end",
                          "value": "{{end}}",
                          "description": "\"The end datetime for the window of readings\" \\\n\"Readings after this datetime will not be included in the results\" \\\n\"A valid 'start' parameter must be included if this parameter is used\"\n"
                        }
                      ],
                      "variable": [
                        {
                          "disabled": false,
                          "type": "any",
                          "value": "{{sensor_id}}",
                          "key": "sensor_id",
                          "description": "(Required) \"The Serial Number of a Sensor, 8 hexadecimal characters long\"\n"
                        }
                      ]
                    },
                    "header": [
                      {
                        "key": "Accept",
                        "value": "application/json"
                      }
                    ],
                    "method": "GET",
                    "auth": null
                  },
                  "response": [
                    {
                      "name": "Readings for a single Sensor",
                      "originalRequest": {
                        "url": {
                          "path": [
                            "api",
                            "v2",
                            "sensors",
                            ":sensor_id",
                            "readings"
                          ],
                          "host": [
                            "{{baseUrl}}"
                          ],
                          "query": [
                            {
                              "key": "start",
                              "value": "{{start}}"
                            },
                            {
                              "key": "end",
                              "value": "{{end}}"
                            },
                            {
                              "key": "token",
                              "value": "{{token}}"
                            }
                          ],
                          "variable": [
                            {
                              "disabled": false,
                              "type": "any",
                              "value": "{{sensor_id}}",
                              "key": "sensor_id",
                              "description": "(Required) \"The Serial Number of a Sensor, 8 hexadecimal characters long\"\n"
                            }
                          ]
                        },
                        "header": [
                          {
                            "key": "Accept",
                            "value": "application/json"
                          }
                        ],
                        "method": "GET",
                        "body": {}
                      },
                      "status": "OK",
                      "code": 200,
                      "header": [
                        {
                          "key": "Content-Type",
                          "value": "application/json"
                        }
                      ],
                      "body": "{\n  \"data\": {\n    \"sensor\": {\n      \"1\": {\n        \"sample_type\": \"ex Excepteur laborum sit ut\",\n        \"units\": \"anim mollit labore proi\",\n        \"readings\": [\n          {\n            \"value\": 5522258.3771986365,\n            \"time\": \"voluptate nisi\"\n          },\n          {\n            \"value\": 78904764.18456382,\n            \"time\": \"magna nulla aliquip\"\n          }\n        ]\n      },\n      \"serial_number\": \"ea reprehenderit elit proident voluptate\",\n      \"sensor_type\": \"elit esse aute\",\n      \"channels\": [\n        22654585.72453764,\n        -95893360.75349317\n      ]\n    }\n  },\n  \"errors\": [\n    \"nulla fugiat sit velit\",\n    \"pariatur ad\"\n  ]\n}",
                      "cookie": [],
                      "_postman_previewlanguage": "json"
                    },
                    {
                      "name": "No valid API token/key values have been provided with the request",
                      "originalRequest": {
                        "url": {
                          "path": [
                            "api",
                            "v2",
                            "sensors",
                            ":sensor_id",
                            "readings"
                          ],
                          "host": [
                            "{{baseUrl}}"
                          ],
                          "query": [
                            {
                              "key": "start",
                              "value": "{{start}}"
                            },
                            {
                              "key": "end",
                              "value": "{{end}}"
                            },
                            {
                              "key": "token",
                              "value": "{{token}}"
                            }
                          ],
                          "variable": [
                            {
                              "disabled": false,
                              "type": "any",
                              "value": "{{sensor_id}}",
                              "key": "sensor_id",
                              "description": "(Required) \"The Serial Number of a Sensor, 8 hexadecimal characters long\"\n"
                            }
                          ]
                        },
                        "method": "GET",
                        "body": {}
                      },
                      "status": "Unauthorized",
                      "code": 401,
                      "header": [
                        {
                          "key": "Content-Type",
                          "value": "text/plain"
                        }
                      ],
                      "body": "",
                      "cookie": [],
                      "_postman_previewlanguage": "text"
                    }
                  ],
                  "event": [
                    {
                      "listen": "test",
                      "script": {
                        "exec": [
                          " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test postman-testplan using AI Type Azure Open AI and AI Model roostgpt-4-32k\n\n\nTest generated for api/v2/sensors/{sensor_id}/readings?start={{start}}&end={{end}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n    responseData = pm.response.json();\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Readings for a single Sensor\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            pm.response.to.have.header(\"Content-Type\");\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n        });\n        pm.test('Response has the `data` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data`)){\n                if(pm.expect(ld.get(pm.response.json(), `data`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data`, null)).to.equal(\"object\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.sensor` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.sensor`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.sensor`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.sensor`, null)).to.equal(\"object\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.sensor.1` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.sensor.1`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.sensor.1`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.sensor.1`, null)).to.equal(\"object\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.sensor.serial_number` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.sensor.serial_number`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.sensor.serial_number`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.sensor.serial_number`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n  \n        pm.test(`data.sensor.serial_number length to be atmost '1000'`,function(){\n            pm.expect(ld.get(responseData, `data.sensor.serial_number`, \"\").length).to.be.at.most(1000);\n        })\n  \n        pm.test(`data.sensor.serial_number length to be alteast '0'`,function(){\n            pm.expect(ld.get(responseData, `data.sensor.serial_number`, \"\").length).to.be.at.least(0);\n        })\n\n        pm.test('Response has the `data.sensor.sensor_type` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.sensor.sensor_type`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.sensor.sensor_type`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.sensor.sensor_type`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n  \n        pm.test(`data.sensor.sensor_type length to be atmost '1000'`,function(){\n            pm.expect(ld.get(responseData, `data.sensor.sensor_type`, \"\").length).to.be.at.most(1000);\n        })\n  \n        pm.test(`data.sensor.sensor_type length to be alteast '0'`,function(){\n            pm.expect(ld.get(responseData, `data.sensor.sensor_type`, \"\").length).to.be.at.least(0);\n        })\n\n        pm.test('Response has the `data.sensor.channels` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.sensor.channels`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.sensor.channels`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `data.sensor.channels`))).to.equal(true);\n                }\n\n            }\n\n        })\n  \n        pm.test(`data.sensor.channels length to be atmost '100'`,function(){\n            pm.expect(ld.get(responseData, `data.sensor.channels`, \"\").length).to.be.at.most(100);\n        })\n  \n        pm.test(`data.sensor.channels length to be atlease '100'`,function(){\n          pm.expect(ld.get(responseData, `data.sensor.channels`, \"\").length).to.be.at.least(0);\n        })\n\n        pm.test('Response has the `errors` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`errors`)){\n                if(pm.expect(ld.get(pm.response.json(), `errors`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `errors`))).to.equal(true);\n                }\n\n            }\n\n        })\n  \n        pm.test(`errors length to be atmost '100'`,function(){\n            pm.expect(ld.get(responseData, `errors`, \"\").length).to.be.at.most(100);\n        })\n  \n        pm.test(`errors length to be atlease '100'`,function(){\n          pm.expect(ld.get(responseData, `errors`, \"\").length).to.be.at.least(0);\n        })\n\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"No valid API token/key values have been provided with the request\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    });\n\n}\n"
                        ],
                        "type": "text/javascript"
                      }
                    }
                  ],
                  "protocolProfileBehavior": {
                    "disableBodyPruning": true
                  }
                },
                {
                  "name": "channels",
                  "item": [
                    {
                      "name": "/api/v2/sensors/:sensor_id/channels",
                      "request": {
                        "name": "/api/v2/sensors/:sensor_id/channels",
                        "description": {},
                        "url": {
                          "path": [
                            "api",
                            "v2",
                            "sensors",
                            ":sensor_id",
                            "channels"
                          ],
                          "host": [
                            "{{baseUrl}}"
                          ],
                          "query": [],
                          "variable": [
                            {
                              "disabled": false,
                              "type": "any",
                              "value": "{{sensor_id}}",
                              "key": "sensor_id",
                              "description": "(Required) \"The Serial Number of a Sensor, 8 hexadecimal characters long\"\n"
                            }
                          ]
                        },
                        "header": [
                          {
                            "key": "Accept",
                            "value": "application/json"
                          }
                        ],
                        "method": "GET",
                        "auth": null
                      },
                      "response": [
                        {
                          "name": "Available channels for a single Sensor",
                          "originalRequest": {
                            "url": {
                              "path": [
                                "api",
                                "v2",
                                "sensors",
                                ":sensor_id",
                                "channels"
                              ],
                              "host": [
                                "{{baseUrl}}"
                              ],
                              "query": [
                                {
                                  "key": "token",
                                  "value": "{{token}}"
                                }
                              ],
                              "variable": [
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{sensor_id}}",
                                  "key": "sensor_id",
                                  "description": "(Required) \"The Serial Number of a Sensor, 8 hexadecimal characters long\"\n"
                                }
                              ]
                            },
                            "header": [
                              {
                                "key": "Accept",
                                "value": "application/json"
                              }
                            ],
                            "method": "GET",
                            "body": {}
                          },
                          "status": "OK",
                          "code": 200,
                          "header": [
                            {
                              "key": "Content-Type",
                              "value": "application/json"
                            }
                          ],
                          "body": "{\n  \"data\": {\n    \"channels\": [\n      27426368.08985637,\n      -52553275.97946735\n    ]\n  },\n  \"errors\": [\n    \"ex\",\n    \"minim\"\n  ]\n}",
                          "cookie": [],
                          "_postman_previewlanguage": "json"
                        },
                        {
                          "name": "No valid API token/key values have been provided with the request",
                          "originalRequest": {
                            "url": {
                              "path": [
                                "api",
                                "v2",
                                "sensors",
                                ":sensor_id",
                                "channels"
                              ],
                              "host": [
                                "{{baseUrl}}"
                              ],
                              "query": [
                                {
                                  "key": "token",
                                  "value": "{{token}}"
                                }
                              ],
                              "variable": [
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{sensor_id}}",
                                  "key": "sensor_id",
                                  "description": "(Required) \"The Serial Number of a Sensor, 8 hexadecimal characters long\"\n"
                                }
                              ]
                            },
                            "method": "GET",
                            "body": {}
                          },
                          "status": "Unauthorized",
                          "code": 401,
                          "header": [
                            {
                              "key": "Content-Type",
                              "value": "text/plain"
                            }
                          ],
                          "body": "",
                          "cookie": [],
                          "_postman_previewlanguage": "text"
                        }
                      ],
                      "event": [
                        {
                          "listen": "test",
                          "script": {
                            "exec": [
                              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test postman-testplan using AI Type Azure Open AI and AI Model roostgpt-4-32k\n\n\nTest generated for api/v2/sensors/{sensor_id}/channels for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n    responseData = pm.response.json();\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Available channels for a single Sensor\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test('Response has the `data` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data`)){\n                if(pm.expect(ld.get(pm.response.json(), `data`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data`, null)).to.equal(\"object\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.channels` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.channels`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.channels`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `data.channels`))).to.equal(true);\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `errors` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`errors`)){\n                if(pm.expect(ld.get(pm.response.json(), `errors`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `errors`))).to.equal(true);\n                }\n\n            }\n\n        })\n\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"No valid API token/key values have been provided with the request\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    });\n\n}\n"
                            ],
                            "type": "text/javascript"
                          }
                        }
                      ],
                      "protocolProfileBehavior": {
                        "disableBodyPruning": true
                      }
                    },
                    {
                      "name": "{channel_id}",
                      "item": [
                        {
                          "name": "/api/v2/sensors/:sensor_id/channels/:channel_id",
                          "request": {
                            "name": "/api/v2/sensors/:sensor_id/channels/:channel_id",
                            "description": {},
                            "url": {
                              "path": [
                                "api",
                                "v2",
                                "sensors",
                                ":sensor_id",
                                "channels",
                                ":channel_id"
                              ],
                              "host": [
                                "{{baseUrl}}"
                              ],
                              "query": [],
                              "variable": [
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{sensor_id}}",
                                  "key": "sensor_id",
                                  "description": "(Required) \"The Serial Number of a Sensor, 8 hexadecimal characters long\"\n"
                                },
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{channel_id}}",
                                  "key": "channel_id",
                                  "description": "(Required) \"The identifier of the channel/input for a given Asset or Sensor\" \\\n\"Must be a value between 1 and 3, with 3 always being a binary channel/input\"\n"
                                }
                              ]
                            },
                            "header": [
                              {
                                "key": "Accept",
                                "value": "application/json"
                              }
                            ],
                            "method": "GET",
                            "auth": null
                          },
                          "response": [
                            {
                              "name": "Detailed information for a single channel/input for a single Sensor",
                              "originalRequest": {
                                "url": {
                                  "path": [
                                    "api",
                                    "v2",
                                    "sensors",
                                    ":sensor_id",
                                    "channels",
                                    ":channel_id"
                                  ],
                                  "host": [
                                    "{{baseUrl}}"
                                  ],
                                  "query": [
                                    {
                                      "key": "token",
                                      "value": "{{token}}"
                                    }
                                  ],
                                  "variable": [
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "{{sensor_id}}",
                                      "key": "sensor_id",
                                      "description": "(Required) \"The Serial Number of a Sensor, 8 hexadecimal characters long\"\n"
                                    },
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "{{channel_id}}",
                                      "key": "channel_id",
                                      "description": "(Required) \"The identifier of the channel/input for a given Asset or Sensor\" \\\n\"Must be a value between 1 and 3, with 3 always being a binary channel/input\"\n"
                                    }
                                  ]
                                },
                                "header": [
                                  {
                                    "key": "Accept",
                                    "value": "application/json"
                                  }
                                ],
                                "method": "GET",
                                "body": {}
                              },
                              "status": "OK",
                              "code": 200,
                              "header": [
                                {
                                  "key": "Content-Type",
                                  "value": "application/json"
                                }
                              ],
                              "body": "{\n  \"data\": {\n    \"sample_type\": \"adipisicing\",\n    \"units\": \"consequat consectetur Lorem aliqua\",\n    \"alarm_limits\": [\n      {\n        \"name\": \"dolore dolore aliqua deserunt\",\n        \"enabled\": \"id proident\",\n        \"type\": \"aliqui\",\n        \"threshold_time\": 14756585.025832295,\n        \"min\": \"velit irure\",\n        \"max\": \"velit laboris labore\"\n      },\n      {\n        \"name\": \"cillum non\",\n        \"enabled\": \"sed Excepteur nostrud ut incididunt\",\n        \"type\": \"et aliqua ve\",\n        \"threshold_time\": 18735755.95812185,\n        \"min\": \"do deserunt cillum occaecat dolore\",\n        \"max\": \"esse\"\n      }\n    ]\n  },\n  \"errors\": [\n    \"in veli\",\n    \"in ex\"\n  ]\n}",
                              "cookie": [],
                              "_postman_previewlanguage": "json"
                            },
                            {
                              "name": "No valid API token/key values have been provided with the request",
                              "originalRequest": {
                                "url": {
                                  "path": [
                                    "api",
                                    "v2",
                                    "sensors",
                                    ":sensor_id",
                                    "channels",
                                    ":channel_id"
                                  ],
                                  "host": [
                                    "{{baseUrl}}"
                                  ],
                                  "query": [
                                    {
                                      "key": "token",
                                      "value": "{{token}}"
                                    }
                                  ],
                                  "variable": [
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "{{sensor_id}}",
                                      "key": "sensor_id",
                                      "description": "(Required) \"The Serial Number of a Sensor, 8 hexadecimal characters long\"\n"
                                    },
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "{{channel_id}}",
                                      "key": "channel_id",
                                      "description": "(Required) \"The identifier of the channel/input for a given Asset or Sensor\" \\\n\"Must be a value between 1 and 3, with 3 always being a binary channel/input\"\n"
                                    }
                                  ]
                                },
                                "method": "GET",
                                "body": {}
                              },
                              "status": "Unauthorized",
                              "code": 401,
                              "header": [
                                {
                                  "key": "Content-Type",
                                  "value": "text/plain"
                                }
                              ],
                              "body": "",
                              "cookie": [],
                              "_postman_previewlanguage": "text"
                            }
                          ],
                          "event": [
                            {
                              "listen": "test",
                              "script": {
                                "exec": [
                                  " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test postman-testplan using AI Type Azure Open AI and AI Model roostgpt-4-32k\n\n\nTest generated for api/v2/sensors/{sensor_id}/channels/{channel_id} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n    responseData = pm.response.json();\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Detailed information for a single channel/input for a single Sensor\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test('Response has the `data` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data`)){\n                if(pm.expect(ld.get(pm.response.json(), `data`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data`, null)).to.equal(\"object\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.sample_type` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.sample_type`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.sample_type`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.sample_type`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.units` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.units`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.units`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.units`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.alarm_limits` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.alarm_limits`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.alarm_limits`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `data.alarm_limits`))).to.equal(true);\n                }\n\n            }\n\n        })\n\n        pm.test(`Each object in the data.alarm_limits field has all the required fields`,function(){\n            pm.expect(pm.response.json()).to.have.nested.property(`data.alarm_limits`);\n            let alarm_limitsArray = ld.get(pm.response.json(), `data.alarm_limits`, \"\");\n            for (let alarm_limits_it = 0; alarm_limits_it < alarm_limitsArray.length; alarm_limits_it++) {\n                let iterator = alarm_limits_it;\n                \t\n        pm.test(`${iterator} element of array 'data.alarm_limits[${alarm_limits_it}].name' has 'name' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `data.alarm_limits[${alarm_limits_it}].name`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`data.alarm_limits[${alarm_limits_it}].name`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'data.alarm_limits[${alarm_limits_it}].enabled' has 'enabled' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `data.alarm_limits[${alarm_limits_it}].enabled`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`data.alarm_limits[${alarm_limits_it}].enabled`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'data.alarm_limits[${alarm_limits_it}].type' has 'type' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `data.alarm_limits[${alarm_limits_it}].type`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`data.alarm_limits[${alarm_limits_it}].type`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'data.alarm_limits[${alarm_limits_it}].threshold_time' has 'threshold_time' as 'number'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `data.alarm_limits[${alarm_limits_it}].threshold_time`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`data.alarm_limits[${alarm_limits_it}].threshold_time`, null)).to.equal(\"number\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'data.alarm_limits[${alarm_limits_it}].min' has 'min' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `data.alarm_limits[${alarm_limits_it}].min`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`data.alarm_limits[${alarm_limits_it}].min`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'data.alarm_limits[${alarm_limits_it}].max' has 'max' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `data.alarm_limits[${alarm_limits_it}].max`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`data.alarm_limits[${alarm_limits_it}].max`, null)).to.equal(\"string\");\n            }\n        })\n\n\n            }\n\n        })\n\n        pm.test('Response has the `errors` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`errors`)){\n                if(pm.expect(ld.get(pm.response.json(), `errors`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `errors`))).to.equal(true);\n                }\n\n            }\n\n        })\n\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"No valid API token/key values have been provided with the request\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    });\n\n}\n"
                                ],
                                "type": "text/javascript"
                              }
                            }
                          ],
                          "protocolProfileBehavior": {
                            "disableBodyPruning": true
                          }
                        },
                        {
                          "name": "/api/v2/sensors/:sensor_id/channels/:channel_id/readings",
                          "request": {
                            "name": "/api/v2/sensors/:sensor_id/channels/:channel_id/readings",
                            "description": {},
                            "url": {
                              "path": [
                                "api",
                                "v2",
                                "sensors",
                                ":sensor_id",
                                "channels",
                                ":channel_id",
                                "readings"
                              ],
                              "host": [
                                "{{baseUrl}}"
                              ],
                              "query": [
                                {
                                  "disabled": false,
                                  "key": "start",
                                  "value": "{{start}}",
                                  "description": "\"The start datetime for the window of readings\" \\\n\"Readings before this datetime will not be included in the results\" \\\n\"If this parameter is not specified, the most recent reading for each Asset will be provided\"\n"
                                },
                                {
                                  "disabled": false,
                                  "key": "end",
                                  "value": "{{end}}",
                                  "description": "\"The end datetime for the window of readings\" \\\n\"Readings after this datetime will not be included in the results\" \\\n\"A valid 'start' parameter must be included if this parameter is used\"\n"
                                }
                              ],
                              "variable": [
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{sensor_id}}",
                                  "key": "sensor_id",
                                  "description": "(Required) \"The Serial Number of a Sensor, 8 hexadecimal characters long\"\n"
                                },
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{channel_id}}",
                                  "key": "channel_id",
                                  "description": "(Required) \"The identifier of the channel/input for a given Asset or Sensor\" \\\n\"Must be a value between 1 and 3, with 3 always being a binary channel/input\"\n"
                                }
                              ]
                            },
                            "header": [
                              {
                                "key": "Accept",
                                "value": "application/json"
                              }
                            ],
                            "method": "GET",
                            "auth": null
                          },
                          "response": [
                            {
                              "name": "Readings for a single channel/input for a single Sensor",
                              "originalRequest": {
                                "url": {
                                  "path": [
                                    "api",
                                    "v2",
                                    "sensors",
                                    ":sensor_id",
                                    "channels",
                                    ":channel_id",
                                    "readings"
                                  ],
                                  "host": [
                                    "{{baseUrl}}"
                                  ],
                                  "query": [
                                    {
                                      "key": "start",
                                      "value": "{{start}}"
                                    },
                                    {
                                      "key": "end",
                                      "value": "{{end}}"
                                    },
                                    {
                                      "key": "token",
                                      "value": "{{token}}"
                                    }
                                  ],
                                  "variable": [
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "{{sensor_id}}",
                                      "key": "sensor_id",
                                      "description": "(Required) \"The Serial Number of a Sensor, 8 hexadecimal characters long\"\n"
                                    },
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "{{channel_id}}",
                                      "key": "channel_id",
                                      "description": "(Required) \"The identifier of the channel/input for a given Asset or Sensor\" \\\n\"Must be a value between 1 and 3, with 3 always being a binary channel/input\"\n"
                                    }
                                  ]
                                },
                                "header": [
                                  {
                                    "key": "Accept",
                                    "value": "application/json"
                                  }
                                ],
                                "method": "GET",
                                "body": {}
                              },
                              "status": "OK",
                              "code": 200,
                              "header": [
                                {
                                  "key": "Content-Type",
                                  "value": "application/json"
                                }
                              ],
                              "body": "{\n  \"data\": {\n    \"1\": {\n      \"sample_type\": \"et fugiat\",\n      \"units\": \"et sint ipsum est\",\n      \"readings\": [\n        {\n          \"value\": -68623434.00496855,\n          \"time\": \"quis Excepteur et dolore\"\n        },\n        {\n          \"value\": -84964124.01047446,\n          \"time\": \"in est dolor dolore reprehenderit\"\n        }\n      ]\n    }\n  },\n  \"errors\": [\n    \"anim\",\n    \"non ull\"\n  ]\n}",
                              "cookie": [],
                              "_postman_previewlanguage": "json"
                            },
                            {
                              "name": "No valid API token/key values have been provided with the request",
                              "originalRequest": {
                                "url": {
                                  "path": [
                                    "api",
                                    "v2",
                                    "sensors",
                                    ":sensor_id",
                                    "channels",
                                    ":channel_id",
                                    "readings"
                                  ],
                                  "host": [
                                    "{{baseUrl}}"
                                  ],
                                  "query": [
                                    {
                                      "key": "start",
                                      "value": "{{start}}"
                                    },
                                    {
                                      "key": "end",
                                      "value": "{{end}}"
                                    },
                                    {
                                      "key": "token",
                                      "value": "{{token}}"
                                    }
                                  ],
                                  "variable": [
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "{{sensor_id}}",
                                      "key": "sensor_id",
                                      "description": "(Required) \"The Serial Number of a Sensor, 8 hexadecimal characters long\"\n"
                                    },
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "{{channel_id}}",
                                      "key": "channel_id",
                                      "description": "(Required) \"The identifier of the channel/input for a given Asset or Sensor\" \\\n\"Must be a value between 1 and 3, with 3 always being a binary channel/input\"\n"
                                    }
                                  ]
                                },
                                "method": "GET",
                                "body": {}
                              },
                              "status": "Unauthorized",
                              "code": 401,
                              "header": [
                                {
                                  "key": "Content-Type",
                                  "value": "text/plain"
                                }
                              ],
                              "body": "",
                              "cookie": [],
                              "_postman_previewlanguage": "text"
                            }
                          ],
                          "event": [
                            {
                              "listen": "test",
                              "script": {
                                "exec": [
                                  " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test postman-testplan using AI Type Azure Open AI and AI Model roostgpt-4-32k\n\n\nTest generated for api/v2/sensors/{sensor_id}/channels/{channel_id}/readings?start={{start}}&end={{end}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n    responseData = pm.response.json();\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Readings for a single channel/input for a single Sensor\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            pm.response.to.have.header(\"Content-Type\");\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n        });\n        pm.test('Response has the `data` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data`)){\n                if(pm.expect(ld.get(pm.response.json(), `data`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data`, null)).to.equal(\"object\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.1` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.1`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.1`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.1`, null)).to.equal(\"object\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.1.sample_type` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.1.sample_type`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.1.sample_type`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.1.sample_type`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n  \n        pm.test(`data.1.sample_type length to be atmost '1000'`,function(){\n            pm.expect(ld.get(responseData, `data.1.sample_type`, \"\").length).to.be.at.most(1000);\n        })\n  \n        pm.test(`data.1.sample_type length to be alteast '0'`,function(){\n            pm.expect(ld.get(responseData, `data.1.sample_type`, \"\").length).to.be.at.least(0);\n        })\n\n        pm.test('Response has the `data.1.units` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.1.units`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.1.units`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.1.units`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n  \n        pm.test(`data.1.units length to be atmost '1000'`,function(){\n            pm.expect(ld.get(responseData, `data.1.units`, \"\").length).to.be.at.most(1000);\n        })\n  \n        pm.test(`data.1.units length to be alteast '0'`,function(){\n            pm.expect(ld.get(responseData, `data.1.units`, \"\").length).to.be.at.least(0);\n        })\n\n        pm.test('Response has the `data.1.readings` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.1.readings`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.1.readings`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `data.1.readings`))).to.equal(true);\n                }\n\n            }\n\n        })\n  \n        pm.test(`data.1.readings length to be atmost '100'`,function(){\n            pm.expect(ld.get(responseData, `data.1.readings`, \"\").length).to.be.at.most(100);\n        })\n  \n        pm.test(`data.1.readings length to be atlease '100'`,function(){\n          pm.expect(ld.get(responseData, `data.1.readings`, \"\").length).to.be.at.least(0);\n        })\n\n        pm.test(`Each object in the data.1.readings field has all the required fields`,function(){\n            pm.expect(pm.response.json()).to.have.nested.property(`data.1.readings`);\n            let readingsArray = ld.get(pm.response.json(), `data.1.readings`, \"\");\n            for (let readings_it = 0; readings_it < readingsArray.length; readings_it++) {\n                let iterator = readings_it;\n                \t\n        pm.test(`${iterator} element of array 'data.1.readings[${readings_it}].value' has 'value' as 'number'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `data.1.readings[${readings_it}].value`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`data.1.readings[${readings_it}].value`, null)).to.equal(\"number\");\n            }\n        })\n\n  \n        pm.expect(ld.get(pm.response.json(), `data.1.readings[${readings_it}].value`, \"\")).to.be.at.least(-137246868.0099371);\n\n        pm.test(`${iterator} element of array 'data.1.readings[${readings_it}].time' has 'time' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `data.1.readings[${readings_it}].time`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`data.1.readings[${readings_it}].time`, null)).to.equal(\"string\");\n            }\n        })\n\n  \n        pm.test(`data.1.readings[${readings_it}].time length to be atmost '1000'`,function(){\n            pm.expect(ld.get(responseData, `data.1.readings[${readings_it}].time`, \"\").length).to.be.at.most(1000);\n        })\n  \n        pm.test(`data.1.readings[${readings_it}].time length to be alteast '0'`,function(){\n            pm.expect(ld.get(responseData, `data.1.readings[${readings_it}].time`, \"\").length).to.be.at.least(0);\n        })\n\n            }\n\n        })\n\n        pm.test('Response has the `errors` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`errors`)){\n                if(pm.expect(ld.get(pm.response.json(), `errors`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `errors`))).to.equal(true);\n                }\n\n            }\n\n        })\n  \n        pm.test(`errors length to be atmost '100'`,function(){\n            pm.expect(ld.get(responseData, `errors`, \"\").length).to.be.at.most(100);\n        })\n  \n        pm.test(`errors length to be atlease '100'`,function(){\n          pm.expect(ld.get(responseData, `errors`, \"\").length).to.be.at.least(0);\n        })\n\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"No valid API token/key values have been provided with the request\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    });\n\n}\n"
                                ],
                                "type": "text/javascript"
                              }
                            }
                          ],
                          "protocolProfileBehavior": {
                            "disableBodyPruning": true
                          }
                        }
                      ],
                      "event": []
                    }
                  ],
                  "event": []
                }
              ],
              "event": []
            }
          ],
          "event": []
        },
        {
          "name": "access_points",
          "item": [
            {
              "name": "/api/v2/access_points",
              "request": {
                "name": "/api/v2/access_points",
                "description": {},
                "url": {
                  "path": [
                    "api",
                    "v2",
                    "access_points"
                  ],
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "query": [
                    {
                      "disabled": false,
                      "key": "sort",
                      "value": "{{sort}}",
                      "description": "\"The parameter with which to sort the highest level of items returned by the endpoint\"\n"
                    },
                    {
                      "disabled": false,
                      "key": "page",
                      "value": "{{page}}",
                      "description": "\"The page number of results to be loaded, e.g. page 3 of 5\" \\\n\"A valid 'per' parameter must be included if this parameter is used\"\n"
                    },
                    {
                      "disabled": false,
                      "key": "per",
                      "value": "{{per}}",
                      "description": "\"The number of results to load per page, e.g. 25 per page\" \\\n\"A valid 'page' parameter must be included if this parameter is used\"\n"
                    },
                    {
                      "disabled": false,
                      "key": "name",
                      "value": "{{name}}",
                      "description": "\"A string to filter returned APs on via their 'name' attribute\" \\\n\"e.g. a value of 'abc' would return all APs with 'abc' in their name\"\n"
                    },
                    {
                      "disabled": false,
                      "key": "serial_number",
                      "value": "{{serial_number}}",
                      "description": "\"A string to filter returned APs on via their 'serial_number' attribute\" \\\n\"e.g. a value of 'abc' would return all APs with 'abc' in their serial number\"\n"
                    },
                    {
                      "disabled": false,
                      "key": "ip_address",
                      "value": "{{ip_address}}",
                      "description": "\"A string to filter returned APs on via their 'ip_address' attribute\" \\\n\"e.g. a value of 'abc' would return all APs with 'abc' in their IP address\"\n"
                    }
                  ],
                  "variable": []
                },
                "header": [
                  {
                    "key": "Accept",
                    "value": "application/json"
                  }
                ],
                "method": "GET",
                "auth": null
              },
              "response": [
                {
                  "name": "All Access Points within the system",
                  "originalRequest": {
                    "url": {
                      "path": [
                        "api",
                        "v2",
                        "access_points"
                      ],
                      "host": [
                        "{{baseUrl}}"
                      ],
                      "query": [
                        {
                          "key": "sort",
                          "value": "{{sort}}"
                        },
                        {
                          "key": "page",
                          "value": "{{page}}"
                        },
                        {
                          "key": "per",
                          "value": "{{per}}"
                        },
                        {
                          "key": "name",
                          "value": "{{name}}"
                        },
                        {
                          "key": "serial_number",
                          "value": "{{serial_number}}"
                        },
                        {
                          "key": "ip_address",
                          "value": "{{ip_address}}"
                        },
                        {
                          "key": "token",
                          "value": "{{token}}"
                        }
                      ],
                      "variable": []
                    },
                    "header": [
                      {
                        "key": "Accept",
                        "value": "application/json"
                      }
                    ],
                    "method": "GET",
                    "body": {}
                  },
                  "status": "OK",
                  "code": 200,
                  "header": [
                    {
                      "key": "Content-Type",
                      "value": "application/json"
                    }
                  ],
                  "body": "{\n  \"data\": [\n    {\n      \"name\": \"Lorem in voluptate exercitation\",\n      \"serial_number\": \"esse incididunt est aliquip\"\n    },\n    {\n      \"name\": \"et sed nostrud tempor irure\",\n      \"serial_number\": \"velit adipisicing\"\n    }\n  ],\n  \"errors\": [\n    \"pariatur elit\",\n    \"Lorem cupidatat labore\"\n  ]\n}",
                  "cookie": [],
                  "_postman_previewlanguage": "json"
                },
                {
                  "name": "No valid API token/key values have been provided with the request",
                  "originalRequest": {
                    "url": {
                      "path": [
                        "api",
                        "v2",
                        "access_points"
                      ],
                      "host": [
                        "{{baseUrl}}"
                      ],
                      "query": [
                        {
                          "key": "sort",
                          "value": "{{sort}}"
                        },
                        {
                          "key": "page",
                          "value": "{{page}}"
                        },
                        {
                          "key": "per",
                          "value": "{{per}}"
                        },
                        {
                          "key": "name",
                          "value": "{{name}}"
                        },
                        {
                          "key": "serial_number",
                          "value": "{{serial_number}}"
                        },
                        {
                          "key": "ip_address",
                          "value": "{{ip_address}}"
                        },
                        {
                          "key": "token",
                          "value": "{{token}}"
                        }
                      ],
                      "variable": []
                    },
                    "method": "GET",
                    "body": {}
                  },
                  "status": "Unauthorized",
                  "code": 401,
                  "header": [
                    {
                      "key": "Content-Type",
                      "value": "text/plain"
                    }
                  ],
                  "body": "",
                  "cookie": [],
                  "_postman_previewlanguage": "text"
                }
              ],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "exec": [
                      " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test postman-testplan using AI Type Azure Open AI and AI Model roostgpt-4-32k\n\n\nTest generated for api/v2/access_points?sort={{sort}}&page={{page}}&per={{per}}&name={{name}}&serial_number={{serial_number}}&ip_address={{ip_address}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n    responseData = pm.response.json();\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"All Access Points within the system\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            pm.response.to.have.header(\"Content-Type\");\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n        });\n        pm.test('Response has the `data` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data`)){\n                if(pm.expect(ld.get(pm.response.json(), `data`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `data`))).to.equal(true);\n                }\n\n            }\n\n        })\n  \n        pm.test(`data length to be atmost '100'`,function(){\n            pm.expect(ld.get(responseData, `data`, \"\").length).to.be.at.most(100);\n        })\n  \n        pm.test(`data length to be atlease '100'`,function(){\n          pm.expect(ld.get(responseData, `data`, \"\").length).to.be.at.least(0);\n        })\n\n        pm.test(`Each object in the data field has all the required fields`,function(){\n            pm.expect(pm.response.json()).to.have.nested.property(`data`);\n            let dataArray = ld.get(pm.response.json(), `data`, \"\");\n            for (let data_it = 0; data_it < dataArray.length; data_it++) {\n                let iterator = data_it;\n                \t\n        pm.test(`${iterator} element of array 'data[${data_it}].name' has 'name' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `data[${data_it}].name`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`data[${data_it}].name`, null)).to.equal(\"string\");\n            }\n        })\n\n  \n        pm.test(`data[${data_it}].name length to be atmost '1000'`,function(){\n            pm.expect(ld.get(responseData, `data[${data_it}].name`, \"\").length).to.be.at.most(1000);\n        })\n  \n        pm.test(`data[${data_it}].name length to be alteast '0'`,function(){\n            pm.expect(ld.get(responseData, `data[${data_it}].name`, \"\").length).to.be.at.least(0);\n        })\n\n        pm.test(`${iterator} element of array 'data[${data_it}].serial_number' has 'serial_number' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `data[${data_it}].serial_number`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`data[${data_it}].serial_number`, null)).to.equal(\"string\");\n            }\n        })\n\n  \n        pm.test(`data[${data_it}].serial_number length to be atmost '1000'`,function(){\n            pm.expect(ld.get(responseData, `data[${data_it}].serial_number`, \"\").length).to.be.at.most(1000);\n        })\n  \n        pm.test(`data[${data_it}].serial_number length to be alteast '0'`,function(){\n            pm.expect(ld.get(responseData, `data[${data_it}].serial_number`, \"\").length).to.be.at.least(0);\n        })\n\n            }\n\n        })\n\n        pm.test('Response has the `errors` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`errors`)){\n                if(pm.expect(ld.get(pm.response.json(), `errors`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `errors`))).to.equal(true);\n                }\n\n            }\n\n        })\n  \n        pm.test(`errors length to be atmost '100'`,function(){\n            pm.expect(ld.get(responseData, `errors`, \"\").length).to.be.at.most(100);\n        })\n  \n        pm.test(`errors length to be atlease '100'`,function(){\n          pm.expect(ld.get(responseData, `errors`, \"\").length).to.be.at.least(0);\n        })\n\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"No valid API token/key values have been provided with the request\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    });\n\n}\n"
                    ],
                    "type": "text/javascript"
                  }
                }
              ],
              "protocolProfileBehavior": {
                "disableBodyPruning": true
              }
            },
            {
              "name": "/api/v2/access_points/:access_point_id",
              "request": {
                "name": "/api/v2/access_points/:access_point_id",
                "description": {},
                "url": {
                  "path": [
                    "api",
                    "v2",
                    "access_points",
                    ":access_point_id"
                  ],
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "query": [],
                  "variable": [
                    {
                      "disabled": false,
                      "type": "any",
                      "value": "{{access_point_id}}",
                      "key": "access_point_id",
                      "description": "(Required) \"The Serial Number of an Access Point, 8 hexadecimal characters long\"\n"
                    }
                  ]
                },
                "header": [
                  {
                    "key": "Accept",
                    "value": "application/json"
                  }
                ],
                "method": "GET",
                "auth": null
              },
              "response": [
                {
                  "name": "Detailed information for a single Access Point",
                  "originalRequest": {
                    "url": {
                      "path": [
                        "api",
                        "v2",
                        "access_points",
                        ":access_point_id"
                      ],
                      "host": [
                        "{{baseUrl}}"
                      ],
                      "query": [
                        {
                          "key": "token",
                          "value": "{{token}}"
                        }
                      ],
                      "variable": [
                        {
                          "disabled": false,
                          "type": "any",
                          "value": "{{access_point_id}}",
                          "key": "access_point_id",
                          "description": "(Required) \"The Serial Number of an Access Point, 8 hexadecimal characters long\"\n"
                        }
                      ]
                    },
                    "header": [
                      {
                        "key": "Accept",
                        "value": "application/json"
                      }
                    ],
                    "method": "GET",
                    "body": {}
                  },
                  "status": "OK",
                  "code": 200,
                  "header": [
                    {
                      "key": "Content-Type",
                      "value": "application/json"
                    }
                  ],
                  "body": "{\n  \"data\": {\n    \"name\": \"Duis minim nostrud\",\n    \"serial_number\": \"anim Duis dolor mollit\",\n    \"ip_address\": \"voluptate dolor sunt exercitation\",\n    \"notes\": \"dolore dolore esse\",\n    \"last_communicated\": \"commodo occaecat in\",\n    \"no_signal_delay\": \"tempor enim\"\n  },\n  \"errors\": [\n    \"Ut tempor proident\",\n    \"id incididunt\"\n  ]\n}",
                  "cookie": [],
                  "_postman_previewlanguage": "json"
                },
                {
                  "name": "No valid API token/key values have been provided with the request",
                  "originalRequest": {
                    "url": {
                      "path": [
                        "api",
                        "v2",
                        "access_points",
                        ":access_point_id"
                      ],
                      "host": [
                        "{{baseUrl}}"
                      ],
                      "query": [
                        {
                          "key": "token",
                          "value": "{{token}}"
                        }
                      ],
                      "variable": [
                        {
                          "disabled": false,
                          "type": "any",
                          "value": "{{access_point_id}}",
                          "key": "access_point_id",
                          "description": "(Required) \"The Serial Number of an Access Point, 8 hexadecimal characters long\"\n"
                        }
                      ]
                    },
                    "method": "GET",
                    "body": {}
                  },
                  "status": "Unauthorized",
                  "code": 401,
                  "header": [
                    {
                      "key": "Content-Type",
                      "value": "text/plain"
                    }
                  ],
                  "body": "",
                  "cookie": [],
                  "_postman_previewlanguage": "text"
                }
              ],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "exec": [
                      " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test postman-testplan using AI Type Azure Open AI and AI Model roostgpt-4-32k\n\n\nTest generated for api/v2/access_points/{access_point_id} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n    responseData = pm.response.json();\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Detailed information for a single Access Point\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test('Response has the `data` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data`)){\n                if(pm.expect(ld.get(pm.response.json(), `data`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data`, null)).to.equal(\"object\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.name` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.name`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.name`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.name`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.serial_number` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.serial_number`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.serial_number`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.serial_number`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.ip_address` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.ip_address`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.ip_address`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.ip_address`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.notes` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.notes`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.notes`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.notes`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.last_communicated` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.last_communicated`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.last_communicated`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.last_communicated`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `data.no_signal_delay` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`data.no_signal_delay`)){\n                if(pm.expect(ld.get(pm.response.json(), `data.no_signal_delay`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `data.no_signal_delay`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `errors` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`errors`)){\n                if(pm.expect(ld.get(pm.response.json(), `errors`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `errors`))).to.equal(true);\n                }\n\n            }\n\n        })\n\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"No valid API token/key values have been provided with the request\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    });\n\n}\n"
                    ],
                    "type": "text/javascript"
                  }
                }
              ],
              "protocolProfileBehavior": {
                "disableBodyPruning": true
              }
            }
          ],
          "event": []
        }
      ],
      "event": []
    }
  ],
  "event": [],
  "variable": [
    {
      "type": "string",
      "value": "https://viewpointdemo.mesalabs.com",
      "key": "baseUrl"
    },
    {
      "type": "integer",
      "value": 200,
      "key": "statusCode"
    }
  ],
  "auth": {
    "type": "apikey",
    "apikey": [
      {
        "key": "key",
        "value": "token"
      },
      {
        "key": "value",
        "value": "{{apiKey}}"
      },
      {
        "key": "in",
        "value": "query"
      }
    ]
  },
  "info": {
    "_postman_id": "c842db70-3403-431b-af8c-73d2d8ac0ac4",
    "name": "VP_Pro_API",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
    "description": {
      "content": "API used to expose Sensor and Asset information to authorized consumers",
      "type": "text/plain"
    }
  }
}